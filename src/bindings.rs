/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRError {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRCompiler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRMetalLibBinary {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRShaderReflection {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRComparisonFunction {
    Never = 1,
    Less = 2,
    Equal = 3,
    LessEqual = 4,
    Greater = 5,
    NotEqual = 6,
    GreaterEqual = 7,
    Always = 8,
}
impl IRDescriptorRangeFlags {
    pub const None: IRDescriptorRangeFlags = IRDescriptorRangeFlags(0);
}
impl IRDescriptorRangeFlags {
    pub const DescriptorsVolatile: IRDescriptorRangeFlags = IRDescriptorRangeFlags(1);
}
impl IRDescriptorRangeFlags {
    pub const DataVolatile: IRDescriptorRangeFlags = IRDescriptorRangeFlags(2);
}
impl IRDescriptorRangeFlags {
    pub const DataStaticWhileSetAtExecute: IRDescriptorRangeFlags = IRDescriptorRangeFlags(4);
}
impl IRDescriptorRangeFlags {
    pub const DataStatic: IRDescriptorRangeFlags = IRDescriptorRangeFlags(8);
}
impl IRDescriptorRangeFlags {
    pub const DescriptorsStaticKeepingBufferBoundsChecks: IRDescriptorRangeFlags =
        IRDescriptorRangeFlags(65536);
}
impl ::std::ops::BitOr<IRDescriptorRangeFlags> for IRDescriptorRangeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRDescriptorRangeFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRDescriptorRangeFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRDescriptorRangeFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRDescriptorRangeFlags> for IRDescriptorRangeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRDescriptorRangeFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRDescriptorRangeFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRDescriptorRangeFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRDescriptorRangeFlags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFilter {
    MinMagMipPoint = 0,
    MinMagPointMipLinear = 1,
    MinPointMagLinearMipPoint = 4,
    MinPointMagMipLinear = 5,
    MinLinearMagMipPoint = 16,
    MinLinearMagPointMipLinear = 17,
    MinMagLinearMipPoint = 20,
    MinMagMipLinear = 21,
    Anisotropic = 85,
    ComparisonMinMagMipPoint = 128,
    ComparisonMinMagPointMipLinear = 129,
    ComparisonMinPointMagLinearMipPoint = 132,
    ComparisonMinPointMagMipLinear = 133,
    ComparisonMinLinearMagMipPoint = 144,
    ComparisonMinLinearMagPointMipLinear = 145,
    ComparisonMinMagLinearMipPoint = 148,
    ComparisonMinMagMipLinear = 149,
    ComparisonAnisotropic = 213,
    MinimumMinMagMipPoint = 256,
    MinimumMinMagPointMipLinear = 257,
    MinimumMinPointMagLinearMipPoint = 260,
    MinimumMinPointMagMipLinear = 261,
    MinimumMinLinearMagMipPoint = 272,
    MinimumMinLinearMagPointMipLinear = 273,
    MinimumMinMagLinearMipPoint = 276,
    MinimumMinMagMipLinear = 277,
    MinimumAnisotropic = 341,
    MaximumMinMagMipPoint = 384,
    MaximumMinMagPointMipLinear = 385,
    MaximumMinPointMagLinearMipPoint = 388,
    MaximumMinPointMagMipLinear = 389,
    MaximumMinLinearMagMipPoint = 400,
    MaximumMinLinearMagPointMipLinear = 401,
    MaximumMinMagLinearMipPoint = 404,
    MaximumMinMagMipLinear = 405,
    MaximumAnisotropic = 469,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFormat {
    Unknown = 0,
    R32G32B32A32Typeless = 1,
    R32G32B32A32Float = 2,
    R32G32B32A32Uint = 3,
    R32G32B32A32Sint = 4,
    R32G32B32Typeless = 5,
    R32G32B32Float = 6,
    R32G32B32Uint = 7,
    R32G32B32Sint = 8,
    R16G16B16A16Typeless = 9,
    R16G16B16A16Float = 10,
    R16G16B16A16Unorm = 11,
    R16G16B16A16Uint = 12,
    R16G16B16A16Snorm = 13,
    R16G16B16A16Sint = 14,
    R32G32Typeless = 15,
    R32G32Float = 16,
    R32G32Uint = 17,
    R32G32Sint = 18,
    R32G8X24Typeless = 19,
    D32FloatS8X24Uint = 20,
    R32FloatX8X24Typeless = 21,
    X32TypelessG8X24Uint = 22,
    R10G10B10A2Typeless = 23,
    R10G10B10A2Unorm = 24,
    R10G10B10A2Uint = 25,
    R11G11B10Float = 26,
    R8G8B8A8Typeless = 27,
    R8G8B8A8Unorm = 28,
    R8G8B8A8Unorm_sRGB = 29,
    R8G8B8A8Uint = 30,
    R8G8B8A8Snorm = 31,
    R8G8B8A8Sint = 32,
    R16G16Typeless = 33,
    R16G16Float = 34,
    R16G16Unorm = 35,
    R16G16Uint = 36,
    R16G16Snorm = 37,
    R16G16Sint = 38,
    R32Typeless = 39,
    D32Float = 40,
    R32Float = 41,
    R32Uint = 42,
    R32Sint = 43,
    R24G8Typeless = 44,
    D24UnormS8Uint = 45,
    R24UnormX8Typeless = 46,
    X24TypelessG8Uint = 47,
    R8G8Typeless = 48,
    R8G8Unorm = 49,
    R8G8Uint = 50,
    R8G8Snorm = 51,
    R8G8Sint = 52,
    R16Typeless = 53,
    R16Float = 54,
    D16Unorm = 55,
    R16Unorm = 56,
    R16Uint = 57,
    R16Snorm = 58,
    R16Sint = 59,
    R8Typeless = 60,
    R8Unorm = 61,
    R8Uint = 62,
    R8Snorm = 63,
    R8Sint = 64,
    A8Unorm = 65,
    R1Unorm = 66,
    R9G9B9E5Sharedexp = 67,
    R8G8B8G8Unorm = 68,
    G8R8G8B8Unorm = 69,
    BC1Typeless = 70,
    BC1Unorm = 71,
    BC1Unorm_sRGB = 72,
    BC2Typeless = 73,
    BC2Unorm = 74,
    BC2Unorm_sRGB = 75,
    BC3Typeless = 76,
    BC3Unorm = 77,
    BC3Unorm_sRGB = 78,
    BC4Typeless = 79,
    BC4Unorm = 80,
    BC4Snorm = 81,
    BC5Typeless = 82,
    BC5Unorm = 83,
    BC5Snorm = 84,
    B5G6R5Unorm = 85,
    B5G5R5A1Unorm = 86,
    B8G8R8A8Unorm = 87,
    B8G8R8X8Unorm = 88,
    R10G10B10XRBiasA2Unorm = 89,
    B8G8R8A8Typeless = 90,
    B8G8R8A8Unorm_sRGB = 91,
    B8G8R8X8Typeless = 92,
    B8G8R8X8Unorm_sRGB = 93,
    BC6HTypeless = 94,
    BC6HUf16 = 95,
    BC6HSf16 = 96,
    BC7Typeless = 97,
    BC7Unorm = 98,
    BC7Unorm_sRGB = 99,
    AYUV = 100,
    Y410 = 101,
    Y416 = 102,
    NV12 = 103,
    P010 = 104,
    P016 = 105,
    _420Opaque = 106,
    YUY2 = 107,
    Y210 = 108,
    Y216 = 109,
    NV11 = 110,
    AI44 = 111,
    IA44 = 112,
    P8 = 113,
    A8P8 = 114,
    B4G4R4A4Unorm = 115,
    P208 = 130,
    V208 = 131,
    V408 = 132,
    SamplerFeedbackMinMipOpaque = 189,
    SamplerFeedbackMipRegionUsedOpaque = 190,
    ForceUint = 4294967295,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputClassification {
    PerVertexData = 0,
    PerInstanceData = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputPrimitive {
    Undefined = 0,
    Point = 1,
    Line = 2,
    Triangle = 3,
    LineAdj = 6,
    TriangleAdj = 7,
    _1ControlPointPatch = 8,
    _2ControlPointPatch = 9,
    _3ControlPointPatch = 10,
    _4ControlPointPatch = 11,
    _5ControlPointPatch = 12,
    _6ControlPointPatch = 13,
    _7ControlPointPatch = 14,
    _8ControlPointPatch = 15,
    _9ControlPointPatch = 16,
    _10ControlPointPatch = 17,
    _11ControlPointPatch = 18,
    _12ControlPointPatch = 19,
    _13ControlPointPatch = 20,
    _14ControlPointPatch = 21,
    _15ControlPointPatch = 22,
    _16ControlPointPatch = 23,
    _17ControlPointPatch = 24,
    _18ControlPointPatch = 25,
    _19ControlPointPatch = 26,
    _20ControlPointPatch = 27,
    _21ControlPointPatch = 28,
    _22ControlPointPatch = 29,
    _23ControlPointPatch = 30,
    _24ControlPointPatch = 31,
    _25ControlPointPatch = 32,
    _26ControlPointPatch = 33,
    _27ControlPointPatch = 34,
    _28ControlPointPatch = 35,
    _29ControlPointPatch = 36,
    _30ControlPointPatch = 37,
    _31ControlPointPatch = 38,
    _32ControlPointPatch = 39,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputTopology {
    Undefined = 0,
    Point = 1,
    Line = 2,
    Triangle = 3,
    Patch = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorOutputPrimitive {
    IRTessellatorOutputUndefined = 0,
    IRTessellatorOutputPoint = 1,
    IRTessellatorOutputLine = 2,
    IRTessellatorOutputTriangleCW = 3,
    IRTessellatorOutputTriangleCCW = 4,
}
impl IRRootDescriptorFlags {
    pub const None: IRRootDescriptorFlags = IRRootDescriptorFlags(0);
}
impl IRRootDescriptorFlags {
    pub const DataVolatile: IRRootDescriptorFlags = IRRootDescriptorFlags(2);
}
impl IRRootDescriptorFlags {
    pub const DataStaticWhileSetAtExecute: IRRootDescriptorFlags = IRRootDescriptorFlags(4);
}
impl IRRootDescriptorFlags {
    pub const DataStatic: IRRootDescriptorFlags = IRRootDescriptorFlags(8);
}
impl ::std::ops::BitOr<IRRootDescriptorFlags> for IRRootDescriptorFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRRootDescriptorFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRRootDescriptorFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRRootDescriptorFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRRootDescriptorFlags> for IRRootDescriptorFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRRootDescriptorFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRRootDescriptorFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRRootDescriptorFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRRootDescriptorFlags(pub ::std::os::raw::c_uint);
impl IRRootSignatureFlags {
    pub const None: IRRootSignatureFlags = IRRootSignatureFlags(0);
}
impl IRRootSignatureFlags {
    pub const AllowInputAssemblerInputLayout: IRRootSignatureFlags = IRRootSignatureFlags(1);
}
impl IRRootSignatureFlags {
    pub const DenyVertexShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(2);
}
impl IRRootSignatureFlags {
    pub const DenyHullShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(4);
}
impl IRRootSignatureFlags {
    pub const DenyDomainShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(8);
}
impl IRRootSignatureFlags {
    pub const DenyGeometryShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(16);
}
impl IRRootSignatureFlags {
    pub const DenyPixelShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(32);
}
impl IRRootSignatureFlags {
    pub const AllowStreamOutput: IRRootSignatureFlags = IRRootSignatureFlags(64);
}
impl IRRootSignatureFlags {
    pub const LocalRootSignature: IRRootSignatureFlags = IRRootSignatureFlags(128);
}
impl IRRootSignatureFlags {
    pub const DenyAmplificationShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(256);
}
impl IRRootSignatureFlags {
    pub const DenyMeshShaderRootAccess: IRRootSignatureFlags = IRRootSignatureFlags(512);
}
impl IRRootSignatureFlags {
    pub const CBVSRVUAVHeapDirectlyIndexed: IRRootSignatureFlags = IRRootSignatureFlags(1024);
}
impl IRRootSignatureFlags {
    pub const SamplerHeapDirectlyIndexed: IRRootSignatureFlags = IRRootSignatureFlags(2048);
}
impl ::std::ops::BitOr<IRRootSignatureFlags> for IRRootSignatureFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRRootSignatureFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRRootSignatureFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRRootSignatureFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRRootSignatureFlags> for IRRootSignatureFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRRootSignatureFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRRootSignatureFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRRootSignatureFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRRootSignatureFlags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRShaderVisibility {
    All = 0,
    Vertex = 1,
    Hull = 2,
    Domain = 3,
    Geometry = 4,
    Pixel = 5,
    Amplification = 6,
    Mesh = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorDomain {
    Undefined = 0,
    Isoline = 1,
    Tri = 2,
    Quad = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorPartitioning {
    Undefined = 0,
    Integer = 1,
    Pow2 = 2,
    FractionalOdd = 3,
    FractionalEven = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTextureAddressMode {
    Wrap = 1,
    Mirror = 2,
    Clamp = 3,
    Border = 4,
    MirrorOnce = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRShaderStage {
    Invalid = 0,
    Vertex = 1,
    Fragment = 2,
    Hull = 3,
    Domain = 4,
    Mesh = 5,
    Amplification = 6,
    Geometry = 7,
    Compute = 8,
    ClosestHit = 9,
    Intersection = 10,
    AnyHit = 11,
    Miss = 12,
    RayGeneration = 13,
    Callable = 14,
    StreamOut = 15,
    StageIn = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRObjectType {
    DXILBytecode = 0,
    MetalIRObject = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRResourceType {
    Table = 0,
    Constant = 1,
    CBV = 2,
    SRV = 3,
    UAV = 4,
    Sampler = 5,
    Invalid = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDescriptorRangeType {
    SRV = 0,
    UAV = 1,
    CBV = 2,
    Sampler = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDescriptorRange {
    pub RangeType: IRDescriptorRangeType,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub OffsetInDescriptorsFromTableStart: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptorTable {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const IRDescriptorRange,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexInputTable {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const IRDescriptorRange,
}
pub type IRVertexInput = IRVertexInputTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootConstants {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Num32BitValues: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptor {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStripCutIndex {
    Disabled = 0,
    _0xFFFF = 1,
    _0xFFFFFFFF = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRRootParameterType {
    DescriptorTable = 0,
    _32BitConstants = 1,
    CBV = 2,
    SRV = 3,
    UAV = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRRootParameter {
    pub ParameterType: IRRootParameterType,
    pub u_1: IRRootParameter_u,
    pub ShaderVisibility: IRShaderVisibility,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRRootParameter_u {
    pub DescriptorTable: IRRootDescriptorTable,
    pub Constants: IRRootConstants,
    pub Descriptor: IRRootDescriptor,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStaticBorderColor {
    TransparentBlack = 0,
    OpaqueBlack = 1,
    OpaqueWhite = 2,
}
impl IRCompatibilityFlags {
    pub const None: IRCompatibilityFlags = IRCompatibilityFlags(0);
}
impl IRCompatibilityFlags {
    pub const BoundsCheck: IRCompatibilityFlags = IRCompatibilityFlags(1);
}
impl IRCompatibilityFlags {
    pub const VertexPositionInfToNan: IRCompatibilityFlags = IRCompatibilityFlags(2);
}
impl IRCompatibilityFlags {
    pub const TextureMinLODClamp: IRCompatibilityFlags = IRCompatibilityFlags(4);
}
impl IRCompatibilityFlags {
    pub const SamplerLODBias: IRCompatibilityFlags = IRCompatibilityFlags(8);
}
impl IRCompatibilityFlags {
    pub const PositionInvariance: IRCompatibilityFlags = IRCompatibilityFlags(16);
}
impl IRCompatibilityFlags {
    pub const SampleNanToZero: IRCompatibilityFlags = IRCompatibilityFlags(32);
}
impl ::std::ops::BitOr<IRCompatibilityFlags> for IRCompatibilityFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRCompatibilityFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRCompatibilityFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRCompatibilityFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRCompatibilityFlags> for IRCompatibilityFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRCompatibilityFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRCompatibilityFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRCompatibilityFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRCompatibilityFlags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRStaticSamplerDescriptor {
    pub Filter: IRFilter,
    pub AddressU: IRTextureAddressMode,
    pub AddressV: IRTextureAddressMode,
    pub AddressW: IRTextureAddressMode,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: IRComparisonFunction,
    pub BorderColor: IRStaticBorderColor,
    pub MinLOD: f32,
    pub MaxLOD: f32,
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub ShaderVisibility: IRShaderVisibility,
}
impl IRRootSignatureVersion {
    pub const _1_0: IRRootSignatureVersion = IRRootSignatureVersion::_1;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRRootSignatureVersion {
    _1 = 1,
    _1_1 = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignatureDescriptor {
    pub NumParameters: u32,
    pub pParameters: *const IRRootParameter,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const IRStaticSamplerDescriptor,
    pub Flags: IRRootSignatureFlags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDescriptorRange1 {
    pub RangeType: IRDescriptorRangeType,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: IRDescriptorRangeFlags,
    pub OffsetInDescriptorsFromTableStart: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptorTable1 {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *mut IRDescriptorRange1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptor1 {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: IRRootDescriptorFlags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRRootParameter1 {
    pub ParameterType: IRRootParameterType,
    pub u_1: IRRootParameter1_u,
    pub ShaderVisibility: IRShaderVisibility,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRRootParameter1_u {
    pub DescriptorTable: IRRootDescriptorTable1,
    pub Constants: IRRootConstants,
    pub Descriptor: IRRootDescriptor1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignatureDescriptor1 {
    pub NumParameters: u32,
    pub pParameters: *mut IRRootParameter1,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *mut IRStaticSamplerDescriptor,
    pub Flags: IRRootSignatureFlags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedRootSignatureDescriptor {
    pub version: IRRootSignatureVersion,
    pub u_1: IRVersionedRootSignatureDescriptor_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedRootSignatureDescriptor_u {
    pub desc_1_0: IRRootSignatureDescriptor,
    pub desc_1_1: IRRootSignatureDescriptor1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRInputElementDescriptor1 {
    pub semanticIndex: u32,
    pub format: IRFormat,
    pub inputSlot: u32,
    pub alignedByteOffset: u32,
    pub inputSlotClass: IRInputClassification,
    pub instanceDataStepRate: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRInputLayoutDescriptor1 {
    pub semanticNames: [*const ::std::os::raw::c_char; 31usize],
    pub inputElementDescs: [IRInputElementDescriptor1; 31usize],
    pub numElements: u32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputLayoutDescriptorVersion {
    _1 = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedInputLayoutDescriptor {
    pub version: IRInputLayoutDescriptorVersion,
    pub u_1: IRVersionedInputLayoutDescriptor_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedInputLayoutDescriptor_u {
    pub desc_1_0: IRInputLayoutDescriptor1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRHitGroupType {
    Triangles = 0,
    ProceduralPrimitive = 1,
}
impl IRRaytracingPipelineFlags {
    pub const None: IRRaytracingPipelineFlags = IRRaytracingPipelineFlags(0);
}
impl IRRaytracingPipelineFlags {
    pub const SkipTriangles: IRRaytracingPipelineFlags = IRRaytracingPipelineFlags(256);
}
impl IRRaytracingPipelineFlags {
    pub const SkipProceduralPrimitives: IRRaytracingPipelineFlags = IRRaytracingPipelineFlags(512);
}
impl ::std::ops::BitOr<IRRaytracingPipelineFlags> for IRRaytracingPipelineFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRRaytracingPipelineFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRRaytracingPipelineFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRRaytracingPipelineFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRRaytracingPipelineFlags> for IRRaytracingPipelineFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRRaytracingPipelineFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRRaytracingPipelineFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRRaytracingPipelineFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRRaytracingPipelineFlags(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRErrorCode {
    NoError = 0,
    ShaderRequiresRootSignature = 1,
    UnrecognizedRootSignatureDescriptor = 2,
    UnrecognizedParameterTypeInRootSignature = 3,
    ResourceNotReferencedByRootSignature = 4,
    ShaderIncompatibleWithDualSourceBlending = 5,
    UnsupportedWaveSize = 6,
    UnsupportedInstruction = 7,
    CompilationError = 8,
    FailedToSynthesizeStageInFunction = 9,
    FailedToSynthesizeStreamOutFunction = 10,
    FailedToSynthesizeIndirectIntersectionFunction = 11,
    UnableToVerifyModule = 12,
    UnableToLinkModule = 13,
    UnrecognizedDXILHeader = 14,
    InvalidRaytracingAttribute = 15,
    Unknown = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRBytecodeOwnership {
    #[doc = " Do not take ownership."]
    None = 0,
    #[doc = " Copy the bytecode."]
    Copy = 1,
}
impl IRCompilerValidationFlags {
    pub const None: IRCompilerValidationFlags = IRCompilerValidationFlags(0);
}
impl IRCompilerValidationFlags {
    pub const ValidateRawRootResources: IRCompilerValidationFlags = IRCompilerValidationFlags(1);
}
impl IRCompilerValidationFlags {
    pub const ValidateAllResourcesBound: IRCompilerValidationFlags = IRCompilerValidationFlags(2);
}
impl IRCompilerValidationFlags {
    pub const ValidateDXIL: IRCompilerValidationFlags = IRCompilerValidationFlags(4);
}
impl IRCompilerValidationFlags {
    pub const All: IRCompilerValidationFlags = IRCompilerValidationFlags(-1);
}
impl ::std::ops::BitOr<IRCompilerValidationFlags> for IRCompilerValidationFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRCompilerValidationFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRCompilerValidationFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRCompilerValidationFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRCompilerValidationFlags> for IRCompilerValidationFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRCompilerValidationFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRCompilerValidationFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRCompilerValidationFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRCompilerValidationFlags(pub ::std::os::raw::c_int);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStageInCodeGenerationMode {
    UseMetalVertexFetch = 0,
    UseSeparateStageInFunction = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDualSourceBlendingConfiguration {
    DecideAtRuntime = 0,
    ForceEnabled = 1,
    ForceDisabled = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDepthFeedbackConfiguration {
    DecideAtRuntime = 0,
    ForceEnabled = 1,
    ForceDisabled = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRGPUFamily {
    Apple6 = 1006,
    Apple7 = 1007,
    Apple8 = 1008,
    Apple9 = 1009,
    Metal3 = 5001,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IROperatingSystem {
    macOS = 0,
    iOS = 1,
    tvOS = 2,
    iOSSimulator = 3,
}
#[repr(u32)]
#[doc = " Function constant types. Values match MTLDataType enum."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFunctionConstantType {
    Bool = 53,
    Int = 29,
    Float = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRFunctionConstant {
    pub name: *const ::std::os::raw::c_char,
    pub type_: IRFunctionConstantType,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRReflectionVersion {
    _1_0 = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRCSInfo_1_0 {
    pub tg_size: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedCSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedCSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedCSInfo_u {
    pub info_1_0: IRCSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexInputInfo_1_0 {
    pub name: *const ::std::os::raw::c_char,
    pub attributeIndex: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVSInfo_1_0 {
    pub instance_id_index: ::std::os::raw::c_int,
    pub vertex_id_index: ::std::os::raw::c_int,
    pub vertex_output_size_in_bytes: u32,
    pub needs_draw_params: bool,
    pub vertex_inputs: *mut IRVertexInputInfo_1_0,
    pub num_vertex_inputs: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedVSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedVSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedVSInfo_u {
    pub info_1_0: IRVSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRFSInfo_1_0 {
    pub num_render_targets: ::std::os::raw::c_int,
    pub rt_index_int: u8,
    pub discards: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedFSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedFSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedFSInfo_u {
    pub info_1_0: IRFSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexOutputInfo_1_0 {
    pub name: *const ::std::os::raw::c_char,
    pub attributeIndex: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRGSInfo_1_0 {
    pub vertex_outputs: *mut IRVertexOutputInfo_1_0,
    pub num_vertex_outputs: usize,
    pub is_passthrough: bool,
    pub rt_array_index_record_id: i32,
    pub viewport_array_index_record_id: i32,
    pub input_primitive: IRInputPrimitive,
    pub max_input_primitives_per_mesh_threadgroup: u32,
    pub max_payload_size_in_bytes: u32,
    pub instance_count: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedGSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedGSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedGSInfo_u {
    pub info_1_0: IRGSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRHSInfo_1_0 {
    pub max_patches_per_object_threadgroup: u32,
    pub max_object_threads_per_patch: u32,
    pub patch_constants_size: u32,
    pub patch_constant_function: *const ::std::os::raw::c_char,
    pub static_payload_size: u32,
    pub payload_size_per_patch: u32,
    pub input_control_point_count: u32,
    pub output_control_point_count: u32,
    pub output_control_point_size: u32,
    pub tessellator_domain: IRTessellatorDomain,
    pub tessellator_partitioning: IRTessellatorPartitioning,
    pub tessellator_output_primitive: IRTessellatorOutputPrimitive,
    pub tessellation_type_half: bool,
    pub max_tessellation_factor: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedHSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedHSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedHSInfo_u {
    pub info_1_0: IRHSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDSInfo_1_0 {
    pub tessellator_domain: IRTessellatorDomain,
    pub max_input_prims_per_mesh_threadgroup: u32,
    pub input_control_point_count: u32,
    pub input_control_point_size: u32,
    pub patch_constants_size: u32,
    pub tessellation_type_half: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedDSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedDSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedDSInfo_u {
    pub info_1_0: IRDSInfo_1_0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRMeshShaderPrimitiveTopology {
    Point = 0,
    Line = 1,
    Triangle = 2,
    Undefined = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRMSInfo_1_0 {
    pub max_vertex_output_count: u32,
    pub max_primitive_output_count: u32,
    pub primitive_topology: IRMeshShaderPrimitiveTopology,
    pub max_payload_size_in_bytes: u32,
    pub num_threads: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedMSInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedMSInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedMSInfo_u {
    pub info_1_0: IRMSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRASInfo_1_0 {
    pub num_threads: [u32; 3usize],
    pub max_payload_size_in_bytes: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedASInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedASInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedASInfo_u {
    pub info_1_0: IRASInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRTInfo_1_0 {
    pub is_indirect_intersection_function: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedRTInfo {
    pub version: IRReflectionVersion,
    pub u_1: IRVersionedRTInfo_u,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedRTInfo_u {
    pub info_1_0: IRRTInfo_1_0,
}
#[doc = " Represents a shader resource location from reflection data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRResourceLocation {
    #[doc = "< Resource type."]
    pub resourceType: IRResourceType,
    #[doc = "< DXIL space of this resource."]
    pub space: u32,
    #[doc = "< DXIL slot of this resource."]
    pub slot: u32,
    #[doc = "< Offset in bytes into the top-level argument buffer."]
    pub topLevelOffset: u32,
    #[doc = "< Size of the entry in the argument buffer in bytes."]
    pub sizeBytes: u64,
    #[doc = "< Name of the resource. String is non-owned and points into the parent reflection object. May be NULL."]
    pub resourceName: *const ::std::os::raw::c_char,
}
extern crate libloading;
pub struct metal_irconverter {
    __library: ::libloading::Library,
    pub IRErrorGetCode: unsafe extern "C" fn(error: *const IRError) -> u32,
    pub IRErrorGetPayload:
        unsafe extern "C" fn(error: *const IRError) -> *const ::std::os::raw::c_void,
    pub IRErrorDestroy: unsafe extern "C" fn(error: *mut IRError),
    pub IRRootSignatureCreateFromDescriptor: unsafe extern "C" fn(
        descriptor: *const IRVersionedRootSignatureDescriptor,
        error: *mut *mut IRError,
    ) -> *mut IRRootSignature,
    pub IRRootSignatureDestroy: unsafe extern "C" fn(sig: *mut IRRootSignature),
    pub IRObjectCreateFromDXIL: unsafe extern "C" fn(
        bytecode: *const u8,
        size: usize,
        bytecodeOwnership: IRBytecodeOwnership,
    ) -> *mut IRObject,
    pub IRObjectDestroy: unsafe extern "C" fn(object: *mut IRObject),
    pub IRObjectGetType: unsafe extern "C" fn(object: *const IRObject) -> IRObjectType,
    pub IRObjectGetMetalIRShaderStage:
        unsafe extern "C" fn(object: *const IRObject) -> IRShaderStage,
    pub IRCompilerSetValidationFlags:
        unsafe extern "C" fn(compiler: *mut IRCompiler, validationFlags: IRCompilerValidationFlags),
    pub IRCompilerCreate: unsafe extern "C" fn() -> *mut IRCompiler,
    pub IRCompilerDestroy: unsafe extern "C" fn(compiler: *mut IRCompiler),
    pub IRCompilerAllocCompileAndLink: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        entryPointName: *const ::std::os::raw::c_char,
        input: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject,
    pub IRCompilerAllocCombineCompileAndLink: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        intersectionFunctionEntryPointName: *const ::std::os::raw::c_char,
        intersectionFunctionBytecode: *const IRObject,
        anyHitFunctionEntryPointName: *const ::std::os::raw::c_char,
        anyHitFunctionBytecode: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject,
    pub IRObjectGetMetalLibBinary: unsafe extern "C" fn(
        obj: *const IRObject,
        stage: IRShaderStage,
        lib: *mut IRMetalLibBinary,
    ) -> bool,
    pub IRCompilerSetStageInGenerationMode: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        stageInCodeGenerationMode: IRStageInCodeGenerationMode,
    ),
    pub IRMetalLibSynthesizeStageInFunction: unsafe extern "C" fn(
        compiler: *const IRCompiler,
        vertexShaderReflection: *const IRShaderReflection,
        layout: *const IRVersionedInputLayoutDescriptor,
        binary: *mut IRMetalLibBinary,
    ) -> bool,
    pub IRObjectGetReflection: unsafe extern "C" fn(
        obj: *const IRObject,
        stage: IRShaderStage,
        reflection: *mut IRShaderReflection,
    ) -> bool,
    pub IRCompilerSetGlobalRootSignature:
        unsafe extern "C" fn(compiler: *mut IRCompiler, rootSignature: *const IRRootSignature),
    pub IRCompilerSetLocalRootSignature:
        unsafe extern "C" fn(compiler: *mut IRCompiler, rootSignature: *const IRRootSignature),
    pub IRCompilerSetHitgroupType:
        unsafe extern "C" fn(compiler: *mut IRCompiler, hitGroupType: IRHitGroupType),
    pub IRObjectGatherRaytracingIntrinsics: unsafe extern "C" fn(
        input: *mut IRObject,
        entryPoint: *const ::std::os::raw::c_char,
    ) -> u64,
    pub IRCompilerSetRayTracingPipelineArguments: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        maxAttributeSizeInBytes: u32,
        raytracingPipelineFlags: IRRaytracingPipelineFlags,
        chs: u64,
        miss: u64,
        anyHit: u64,
        callableArgs: u64,
        maxRecursiveDepth: ::std::os::raw::c_int,
    ),
    pub IRCompilerSetCompatibilityFlags:
        unsafe extern "C" fn(compiler: *mut IRCompiler, flags: IRCompatibilityFlags),
    pub IRCompilerSetInputTopology:
        unsafe extern "C" fn(compiler: *mut IRCompiler, inputTopology: IRInputTopology),
    pub IRCompilerEnableGeometryAndTessellationEmulation:
        unsafe extern "C" fn(compiler: *mut IRCompiler, enable: bool),
    pub IRCompilerSetDualSourceBlendingConfiguration: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        configuration: IRDualSourceBlendingConfiguration,
    ),
    pub IRCompilerSetDepthFeedbackConfiguration: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        configuration: IRDepthFeedbackConfiguration,
    ),
    pub IRCompilerSetIntRTMask: unsafe extern "C" fn(compiler: *mut IRCompiler, intRTMask: u8),
    pub IRMetalLibSynthesizeIndirectRayDispatchFunction:
        unsafe extern "C" fn(compiler: *const IRCompiler, binary: *mut IRMetalLibBinary) -> bool,
    pub IRMetalLibSynthesizeIndirectIntersectionFunction:
        unsafe extern "C" fn(compiler: *const IRCompiler, binary: *mut IRMetalLibBinary) -> bool,
    pub IRCompilerSetEntryPointName:
        unsafe extern "C" fn(compiler: *mut IRCompiler, newName: *const ::std::os::raw::c_char),
    pub IRCompilerSetMinimumGPUFamily:
        unsafe extern "C" fn(compiler: *mut IRCompiler, family: IRGPUFamily),
    pub IRCompilerIgnoreRootSignature:
        unsafe extern "C" fn(compiler: *mut IRCompiler, ignoreEmbeddedRootSignature: bool),
    pub IRCompilerSetMinimumDeploymentTarget: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        operatingSystem: IROperatingSystem,
        version: *const ::std::os::raw::c_char,
    ),
    pub IRMetalLibBinaryCreate: unsafe extern "C" fn() -> *mut IRMetalLibBinary,
    pub IRMetalLibBinaryDestroy: unsafe extern "C" fn(lib: *mut IRMetalLibBinary),
    pub IRMetalLibGetBytecode:
        unsafe extern "C" fn(lib: *const IRMetalLibBinary, outBytecode: *mut u8) -> usize,
    pub IRMetalLibGetBytecodeSize: unsafe extern "C" fn(lib: *const IRMetalLibBinary) -> usize,
    pub IRObjectSerialize: unsafe extern "C" fn(
        outputPath: *const ::std::os::raw::c_char,
        obj: *const IRObject,
        stage: IRShaderStage,
    ) -> bool,
    pub IRShaderReflectionCreate: unsafe extern "C" fn() -> *mut IRShaderReflection,
    pub IRShaderReflectionDestroy: unsafe extern "C" fn(reflection: *mut IRShaderReflection),
    pub IRShaderReflectionGetEntryPointFunctionName:
        unsafe extern "C" fn(
            reflection: *const IRShaderReflection,
        ) -> *const ::std::os::raw::c_char,
    pub IRShaderReflectionNeedsFunctionConstants:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> bool,
    pub IRShaderReflectionGetFunctionConstantCount:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> usize,
    pub IRShaderReflectionCopyFunctionConstants: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        functionConstants: *mut IRFunctionConstant,
    ),
    pub IRShaderReflectionReleaseFunctionConstants: unsafe extern "C" fn(
        functionConstants: *mut IRFunctionConstant,
        functionConstantCount: usize,
    ),
    pub IRShaderReflectionCopyComputeInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyVertexInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyFragmentInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyGeometryInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyHullInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        hsinfo: *mut IRVersionedHSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyDomainInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyMeshInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        msinfo: *mut IRVersionedMSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyAmplificationInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        asinfo: *mut IRVersionedASInfo,
    ) -> bool,
    pub IRShaderReflectionCopyRaytracingInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        rtinfo: *mut IRVersionedRTInfo,
    ) -> bool,
    pub IRShaderReflectionReleaseComputeInfo:
        unsafe extern "C" fn(csinfo: *mut IRVersionedCSInfo) -> bool,
    pub IRShaderReflectionReleaseVertexInfo:
        unsafe extern "C" fn(vsinfo: *mut IRVersionedVSInfo) -> bool,
    pub IRShaderReflectionReleaseFragmentInfo:
        unsafe extern "C" fn(fsinfo: *mut IRVersionedFSInfo) -> bool,
    pub IRShaderReflectionReleaseGeometryInfo:
        unsafe extern "C" fn(gsinfo: *mut IRVersionedGSInfo) -> bool,
    pub IRShaderReflectionReleaseHullInfo:
        unsafe extern "C" fn(hsinfo: *mut IRVersionedHSInfo) -> bool,
    pub IRShaderReflectionReleaseDomainInfo:
        unsafe extern "C" fn(dsinfo: *mut IRVersionedDSInfo) -> bool,
    pub IRShaderReflectionReleaseMeshInfo:
        unsafe extern "C" fn(msinfo: *mut IRVersionedMSInfo) -> bool,
    pub IRShaderReflectionReleaseAmplificationInfo:
        unsafe extern "C" fn(asinfo: *mut IRVersionedASInfo) -> bool,
    pub IRShaderReflectionReleaseRaytracingInfo:
        unsafe extern "C" fn(rtinfo: *mut IRVersionedRTInfo) -> bool,
    pub IRShaderReflectionGetResourceCount:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> usize,
    pub IRShaderReflectionGetResourceLocations: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        resourceLocations: *mut IRResourceLocation,
    ),
    pub IRRootSignatureGetResourceCount:
        unsafe extern "C" fn(rootSignature: *const IRRootSignature) -> usize,
    pub IRRootSignatureGetResourceLocations: unsafe extern "C" fn(
        rootSignature: *const IRRootSignature,
        resourceLocations: *mut IRResourceLocation,
    ),
    pub IRShaderReflectionAllocStringAndSerialize:
        unsafe extern "C" fn(reflection: *mut IRShaderReflection) -> *const ::std::os::raw::c_char,
    pub IRShaderReflectionFreeString:
        unsafe extern "C" fn(serialized: *const ::std::os::raw::c_char),
    pub IRShaderReflectionDeserialize: unsafe extern "C" fn(
        blob: *const ::std::os::raw::c_char,
        reflection: *mut IRShaderReflection,
    ),
    pub IRVersionedRootSignatureDescriptorAllocStringAndSerialize:
        unsafe extern "C" fn(
            rootSignatureDescriptor: *mut IRVersionedRootSignatureDescriptor,
        ) -> *const ::std::os::raw::c_char,
    pub IRVersionedRootSignatureDescriptorFreeString:
        unsafe extern "C" fn(serialized: *const ::std::os::raw::c_char),
    pub IRVersionedRootSignatureDescriptorDeserialize: unsafe extern "C" fn(
        serialized: *const ::std::os::raw::c_char,
        rootSignatureDescriptor: *mut IRVersionedRootSignatureDescriptor,
    ) -> bool,
}
impl metal_irconverter {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let IRErrorGetCode = __library.get(b"IRErrorGetCode\0").map(|sym| *sym)?;
        let IRErrorGetPayload = __library.get(b"IRErrorGetPayload\0").map(|sym| *sym)?;
        let IRErrorDestroy = __library.get(b"IRErrorDestroy\0").map(|sym| *sym)?;
        let IRRootSignatureCreateFromDescriptor = __library
            .get(b"IRRootSignatureCreateFromDescriptor\0")
            .map(|sym| *sym)?;
        let IRRootSignatureDestroy = __library.get(b"IRRootSignatureDestroy\0").map(|sym| *sym)?;
        let IRObjectCreateFromDXIL = __library.get(b"IRObjectCreateFromDXIL\0").map(|sym| *sym)?;
        let IRObjectDestroy = __library.get(b"IRObjectDestroy\0").map(|sym| *sym)?;
        let IRObjectGetType = __library.get(b"IRObjectGetType\0").map(|sym| *sym)?;
        let IRObjectGetMetalIRShaderStage = __library
            .get(b"IRObjectGetMetalIRShaderStage\0")
            .map(|sym| *sym)?;
        let IRCompilerSetValidationFlags = __library
            .get(b"IRCompilerSetValidationFlags\0")
            .map(|sym| *sym)?;
        let IRCompilerCreate = __library.get(b"IRCompilerCreate\0").map(|sym| *sym)?;
        let IRCompilerDestroy = __library.get(b"IRCompilerDestroy\0").map(|sym| *sym)?;
        let IRCompilerAllocCompileAndLink = __library
            .get(b"IRCompilerAllocCompileAndLink\0")
            .map(|sym| *sym)?;
        let IRCompilerAllocCombineCompileAndLink = __library
            .get(b"IRCompilerAllocCombineCompileAndLink\0")
            .map(|sym| *sym)?;
        let IRObjectGetMetalLibBinary = __library
            .get(b"IRObjectGetMetalLibBinary\0")
            .map(|sym| *sym)?;
        let IRCompilerSetStageInGenerationMode = __library
            .get(b"IRCompilerSetStageInGenerationMode\0")
            .map(|sym| *sym)?;
        let IRMetalLibSynthesizeStageInFunction = __library
            .get(b"IRMetalLibSynthesizeStageInFunction\0")
            .map(|sym| *sym)?;
        let IRObjectGetReflection = __library.get(b"IRObjectGetReflection\0").map(|sym| *sym)?;
        let IRCompilerSetGlobalRootSignature = __library
            .get(b"IRCompilerSetGlobalRootSignature\0")
            .map(|sym| *sym)?;
        let IRCompilerSetLocalRootSignature = __library
            .get(b"IRCompilerSetLocalRootSignature\0")
            .map(|sym| *sym)?;
        let IRCompilerSetHitgroupType = __library
            .get(b"IRCompilerSetHitgroupType\0")
            .map(|sym| *sym)?;
        let IRObjectGatherRaytracingIntrinsics = __library
            .get(b"IRObjectGatherRaytracingIntrinsics\0")
            .map(|sym| *sym)?;
        let IRCompilerSetRayTracingPipelineArguments = __library
            .get(b"IRCompilerSetRayTracingPipelineArguments\0")
            .map(|sym| *sym)?;
        let IRCompilerSetCompatibilityFlags = __library
            .get(b"IRCompilerSetCompatibilityFlags\0")
            .map(|sym| *sym)?;
        let IRCompilerSetInputTopology = __library
            .get(b"IRCompilerSetInputTopology\0")
            .map(|sym| *sym)?;
        let IRCompilerEnableGeometryAndTessellationEmulation = __library
            .get(b"IRCompilerEnableGeometryAndTessellationEmulation\0")
            .map(|sym| *sym)?;
        let IRCompilerSetDualSourceBlendingConfiguration = __library
            .get(b"IRCompilerSetDualSourceBlendingConfiguration\0")
            .map(|sym| *sym)?;
        let IRCompilerSetDepthFeedbackConfiguration = __library
            .get(b"IRCompilerSetDepthFeedbackConfiguration\0")
            .map(|sym| *sym)?;
        let IRCompilerSetIntRTMask = __library.get(b"IRCompilerSetIntRTMask\0").map(|sym| *sym)?;
        let IRMetalLibSynthesizeIndirectRayDispatchFunction = __library
            .get(b"IRMetalLibSynthesizeIndirectRayDispatchFunction\0")
            .map(|sym| *sym)?;
        let IRMetalLibSynthesizeIndirectIntersectionFunction = __library
            .get(b"IRMetalLibSynthesizeIndirectIntersectionFunction\0")
            .map(|sym| *sym)?;
        let IRCompilerSetEntryPointName = __library
            .get(b"IRCompilerSetEntryPointName\0")
            .map(|sym| *sym)?;
        let IRCompilerSetMinimumGPUFamily = __library
            .get(b"IRCompilerSetMinimumGPUFamily\0")
            .map(|sym| *sym)?;
        let IRCompilerIgnoreRootSignature = __library
            .get(b"IRCompilerIgnoreRootSignature\0")
            .map(|sym| *sym)?;
        let IRCompilerSetMinimumDeploymentTarget = __library
            .get(b"IRCompilerSetMinimumDeploymentTarget\0")
            .map(|sym| *sym)?;
        let IRMetalLibBinaryCreate = __library.get(b"IRMetalLibBinaryCreate\0").map(|sym| *sym)?;
        let IRMetalLibBinaryDestroy = __library
            .get(b"IRMetalLibBinaryDestroy\0")
            .map(|sym| *sym)?;
        let IRMetalLibGetBytecode = __library.get(b"IRMetalLibGetBytecode\0").map(|sym| *sym)?;
        let IRMetalLibGetBytecodeSize = __library
            .get(b"IRMetalLibGetBytecodeSize\0")
            .map(|sym| *sym)?;
        let IRObjectSerialize = __library.get(b"IRObjectSerialize\0").map(|sym| *sym)?;
        let IRShaderReflectionCreate = __library
            .get(b"IRShaderReflectionCreate\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionDestroy = __library
            .get(b"IRShaderReflectionDestroy\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetEntryPointFunctionName = __library
            .get(b"IRShaderReflectionGetEntryPointFunctionName\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionNeedsFunctionConstants = __library
            .get(b"IRShaderReflectionNeedsFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetFunctionConstantCount = __library
            .get(b"IRShaderReflectionGetFunctionConstantCount\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyFunctionConstants = __library
            .get(b"IRShaderReflectionCopyFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseFunctionConstants = __library
            .get(b"IRShaderReflectionReleaseFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyComputeInfo = __library
            .get(b"IRShaderReflectionCopyComputeInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyVertexInfo = __library
            .get(b"IRShaderReflectionCopyVertexInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyFragmentInfo = __library
            .get(b"IRShaderReflectionCopyFragmentInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyGeometryInfo = __library
            .get(b"IRShaderReflectionCopyGeometryInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyHullInfo = __library
            .get(b"IRShaderReflectionCopyHullInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyDomainInfo = __library
            .get(b"IRShaderReflectionCopyDomainInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyMeshInfo = __library
            .get(b"IRShaderReflectionCopyMeshInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyAmplificationInfo = __library
            .get(b"IRShaderReflectionCopyAmplificationInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyRaytracingInfo = __library
            .get(b"IRShaderReflectionCopyRaytracingInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseComputeInfo = __library
            .get(b"IRShaderReflectionReleaseComputeInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseVertexInfo = __library
            .get(b"IRShaderReflectionReleaseVertexInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseFragmentInfo = __library
            .get(b"IRShaderReflectionReleaseFragmentInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseGeometryInfo = __library
            .get(b"IRShaderReflectionReleaseGeometryInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseHullInfo = __library
            .get(b"IRShaderReflectionReleaseHullInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseDomainInfo = __library
            .get(b"IRShaderReflectionReleaseDomainInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseMeshInfo = __library
            .get(b"IRShaderReflectionReleaseMeshInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseAmplificationInfo = __library
            .get(b"IRShaderReflectionReleaseAmplificationInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseRaytracingInfo = __library
            .get(b"IRShaderReflectionReleaseRaytracingInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetResourceCount = __library
            .get(b"IRShaderReflectionGetResourceCount\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetResourceLocations = __library
            .get(b"IRShaderReflectionGetResourceLocations\0")
            .map(|sym| *sym)?;
        let IRRootSignatureGetResourceCount = __library
            .get(b"IRRootSignatureGetResourceCount\0")
            .map(|sym| *sym)?;
        let IRRootSignatureGetResourceLocations = __library
            .get(b"IRRootSignatureGetResourceLocations\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionAllocStringAndSerialize = __library
            .get(b"IRShaderReflectionAllocStringAndSerialize\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionFreeString = __library
            .get(b"IRShaderReflectionFreeString\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionDeserialize = __library
            .get(b"IRShaderReflectionDeserialize\0")
            .map(|sym| *sym)?;
        let IRVersionedRootSignatureDescriptorAllocStringAndSerialize = __library
            .get(b"IRVersionedRootSignatureDescriptorAllocStringAndSerialize\0")
            .map(|sym| *sym)?;
        let IRVersionedRootSignatureDescriptorFreeString = __library
            .get(b"IRVersionedRootSignatureDescriptorFreeString\0")
            .map(|sym| *sym)?;
        let IRVersionedRootSignatureDescriptorDeserialize = __library
            .get(b"IRVersionedRootSignatureDescriptorDeserialize\0")
            .map(|sym| *sym)?;
        Ok(metal_irconverter {
            __library,
            IRErrorGetCode,
            IRErrorGetPayload,
            IRErrorDestroy,
            IRRootSignatureCreateFromDescriptor,
            IRRootSignatureDestroy,
            IRObjectCreateFromDXIL,
            IRObjectDestroy,
            IRObjectGetType,
            IRObjectGetMetalIRShaderStage,
            IRCompilerSetValidationFlags,
            IRCompilerCreate,
            IRCompilerDestroy,
            IRCompilerAllocCompileAndLink,
            IRCompilerAllocCombineCompileAndLink,
            IRObjectGetMetalLibBinary,
            IRCompilerSetStageInGenerationMode,
            IRMetalLibSynthesizeStageInFunction,
            IRObjectGetReflection,
            IRCompilerSetGlobalRootSignature,
            IRCompilerSetLocalRootSignature,
            IRCompilerSetHitgroupType,
            IRObjectGatherRaytracingIntrinsics,
            IRCompilerSetRayTracingPipelineArguments,
            IRCompilerSetCompatibilityFlags,
            IRCompilerSetInputTopology,
            IRCompilerEnableGeometryAndTessellationEmulation,
            IRCompilerSetDualSourceBlendingConfiguration,
            IRCompilerSetDepthFeedbackConfiguration,
            IRCompilerSetIntRTMask,
            IRMetalLibSynthesizeIndirectRayDispatchFunction,
            IRMetalLibSynthesizeIndirectIntersectionFunction,
            IRCompilerSetEntryPointName,
            IRCompilerSetMinimumGPUFamily,
            IRCompilerIgnoreRootSignature,
            IRCompilerSetMinimumDeploymentTarget,
            IRMetalLibBinaryCreate,
            IRMetalLibBinaryDestroy,
            IRMetalLibGetBytecode,
            IRMetalLibGetBytecodeSize,
            IRObjectSerialize,
            IRShaderReflectionCreate,
            IRShaderReflectionDestroy,
            IRShaderReflectionGetEntryPointFunctionName,
            IRShaderReflectionNeedsFunctionConstants,
            IRShaderReflectionGetFunctionConstantCount,
            IRShaderReflectionCopyFunctionConstants,
            IRShaderReflectionReleaseFunctionConstants,
            IRShaderReflectionCopyComputeInfo,
            IRShaderReflectionCopyVertexInfo,
            IRShaderReflectionCopyFragmentInfo,
            IRShaderReflectionCopyGeometryInfo,
            IRShaderReflectionCopyHullInfo,
            IRShaderReflectionCopyDomainInfo,
            IRShaderReflectionCopyMeshInfo,
            IRShaderReflectionCopyAmplificationInfo,
            IRShaderReflectionCopyRaytracingInfo,
            IRShaderReflectionReleaseComputeInfo,
            IRShaderReflectionReleaseVertexInfo,
            IRShaderReflectionReleaseFragmentInfo,
            IRShaderReflectionReleaseGeometryInfo,
            IRShaderReflectionReleaseHullInfo,
            IRShaderReflectionReleaseDomainInfo,
            IRShaderReflectionReleaseMeshInfo,
            IRShaderReflectionReleaseAmplificationInfo,
            IRShaderReflectionReleaseRaytracingInfo,
            IRShaderReflectionGetResourceCount,
            IRShaderReflectionGetResourceLocations,
            IRRootSignatureGetResourceCount,
            IRRootSignatureGetResourceLocations,
            IRShaderReflectionAllocStringAndSerialize,
            IRShaderReflectionFreeString,
            IRShaderReflectionDeserialize,
            IRVersionedRootSignatureDescriptorAllocStringAndSerialize,
            IRVersionedRootSignatureDescriptorFreeString,
            IRVersionedRootSignatureDescriptorDeserialize,
        })
    }
    #[doc = " Obtain the error code of an error.\n @param error error object to query.\n @return error code."]
    pub unsafe fn IRErrorGetCode(&self, error: *const IRError) -> u32 {
        (self.IRErrorGetCode)(error)
    }
    #[doc = " Obtain any payload associated with an error.\n @param error error object to query.\n @return error payload. You must cast this pointer to the appropriate error payload struct for the error code."]
    pub unsafe fn IRErrorGetPayload(&self, error: *const IRError) -> *const ::std::os::raw::c_void {
        (self.IRErrorGetPayload)(error)
    }
    #[doc = " Release resources associated with an error object.\n @param error error objects for which to release its associated resources."]
    pub unsafe fn IRErrorDestroy(&self, error: *mut IRError) {
        (self.IRErrorDestroy)(error)
    }
    #[doc = " Create a new root signature from its descriptor.\n @param descriptor description of the root signature to create.\n @param error on return, if the compiler generates any errors, this optional out parameter contains error information. If an error occurs and this parameter is non-NULL, you must free it by calling IRErrorDestroy.\n @return a new root signature suitable for configuring the top-level argument buffer layout of the produced MetalIR, or NULL upon encountering an error. You must destroy this object by calling IRRootSignatureDestroy."]
    pub unsafe fn IRRootSignatureCreateFromDescriptor(
        &self,
        descriptor: *const IRVersionedRootSignatureDescriptor,
        error: *mut *mut IRError,
    ) -> *mut IRRootSignature {
        (self.IRRootSignatureCreateFromDescriptor)(descriptor, error)
    }
    #[doc = " Destroy a root signature object.\n @param sig root signature object to destroy."]
    pub unsafe fn IRRootSignatureDestroy(&self, sig: *mut IRRootSignature) {
        (self.IRRootSignatureDestroy)(sig)
    }
    #[doc = " Create a DXIL object from DXIL bytecode.\n @param bytecode bytecode representing legal DXIL. When using IRBytecodeOwnershipNone, you must ensure this buffer is not freed while the returned object is in use.\n @param size size of the bytecode in bytes.\n @param bytecodeOwnership determine whether the IRObject shall copy the bytecode or just hold a weak reference.\n @return a new DXIL object representing the DXIL shader. You must destroy this object by calling IRObjectDestroy."]
    pub unsafe fn IRObjectCreateFromDXIL(
        &self,
        bytecode: *const u8,
        size: usize,
        bytecodeOwnership: IRBytecodeOwnership,
    ) -> *mut IRObject {
        (self.IRObjectCreateFromDXIL)(bytecode, size, bytecodeOwnership)
    }
    #[doc = " Destroy a IRObject.\n @param object IRObject to destroy."]
    pub unsafe fn IRObjectDestroy(&self, object: *mut IRObject) {
        (self.IRObjectDestroy)(object)
    }
    #[doc = " Query a IRObject's type.\n @param object IRObject to query.\n @return IRObjectTypeDXILBytecode if the object represents DXIL bytecode, IRObjectTypeMetalIRObject if the object represents MetalIR bytecode."]
    pub unsafe fn IRObjectGetType(&self, object: *const IRObject) -> IRObjectType {
        (self.IRObjectGetType)(object)
    }
    #[doc = " Query the shader stage of this IRObject.\n @param object IRObject to query.\n @return the shader stage of this IRObject."]
    pub unsafe fn IRObjectGetMetalIRShaderStage(&self, object: *const IRObject) -> IRShaderStage {
        (self.IRObjectGetMetalIRShaderStage)(object)
    }
    #[doc = " Set a compiler's compile-time validation flags.\n @param compiler compiler for which to set the flags.\n @param validationFlags validation flags denoting the checks the compiler performs."]
    pub unsafe fn IRCompilerSetValidationFlags(
        &self,
        compiler: *mut IRCompiler,
        validationFlags: IRCompilerValidationFlags,
    ) {
        (self.IRCompilerSetValidationFlags)(compiler, validationFlags)
    }
    #[doc = " Create a new compiler instance.\n @return a new compiler instance. You must destroy this object by calling IRCompilerDestroy."]
    pub unsafe fn IRCompilerCreate(&self) -> *mut IRCompiler {
        (self.IRCompilerCreate)()
    }
    #[doc = " Destroy a compiler instance.\n @param compiler compiler to destroy."]
    pub unsafe fn IRCompilerDestroy(&self, compiler: *mut IRCompiler) {
        (self.IRCompilerDestroy)(compiler)
    }
    #[doc = " Allocate a new object and populate it with the results of compiling and linking IR bytecode.\n @note Prior calls to `IRCompilerSetHitgroupType`, `IRCompilerSetRayTracingPipelineArguments`, `IRCompilerSetGlobalRootSignature`, `IRCompilerSetLocalRootSignature` influence the bytecode this function produces.\n @note you need to call `IRCompilerSetRayTracingPipelineArguments` before compiling ray tracing shaders.\n @param compiler compiler to use for the translation process.\n @param entryPointName optional entry point name to compile when converting a library with multiple entry points.\n @param input input IR object.\n @param error on return, if the compiler generates any errors, this optional out parameter contains error information. If an error occurs and this parameter is non-NULL, you must free it by calling IRErrorDestroy.\n @return an IR Object containing MetalIR compiled from the input IR, or NULL if an error occurs. You must destroy this object by calling IRObjectDestroy."]
    pub unsafe fn IRCompilerAllocCompileAndLink(
        &self,
        compiler: *mut IRCompiler,
        entryPointName: *const ::std::os::raw::c_char,
        input: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject {
        (self.IRCompilerAllocCompileAndLink)(compiler, entryPointName, input, error)
    }
    #[doc = " Allocate a new object and populate with the results of combining, compiling, and linking IR bytecode of an intersection and an any-hit function.\n This function allows representing the interactions between intersection and any-hit shaders on Metal, where these functions are fused together.\n @warning Ensure you call `IRCompilerSetHitgroupType` prior to this function to specify the intersection type.\n @note One of parameters `intersectionFunctionBytecode` and `anyHitFunctionBytecode` needs to be non-NULL.\n @note If both parameters are non-NULL, this function uses the `anyHitfunctionBytecode` the latter references.\n @note Prior calls to `IRCompilerSetHitgroupType`, `IRCompilerSetRayTracingPipelineArguments`, `IRCompilerSetGlobalRootSignature`, `IRCompilerSetLocalRootSignature` influence the bytecode this function produces.\n @note you need to call `IRCompilerSetRayTracingPipelineArguments` before compiling ray tracing shaders.\n @param compiler compiler to use for the translation process.\n @param intersectionFunctionEntryPointName optional entry point name corresponding to the intersection function.\n @param intersectionFunctionBytecode optional input bytecode that provides the intersection function bytecode.\n @param anyHitFunctionEntryPointName optional entry point name corresponding to the any-hit function.\n @param anyHitFunctionBytecode optional input bytecode that provides the any-hit function\n @param error on return, if the compiler generates any errors, this optional out parameter contains error information. If an error occurs and this parameter is non-NULL, you must free it by calling IRErrorDestroy.\n @return an IR Object containing MetalIR compiled from the input IR, or NULL if an error occurs. You must destroy this object by calling IRObjectDestroy."]
    pub unsafe fn IRCompilerAllocCombineCompileAndLink(
        &self,
        compiler: *mut IRCompiler,
        intersectionFunctionEntryPointName: *const ::std::os::raw::c_char,
        intersectionFunctionBytecode: *const IRObject,
        anyHitFunctionEntryPointName: *const ::std::os::raw::c_char,
        anyHitFunctionBytecode: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject {
        (self.IRCompilerAllocCombineCompileAndLink)(
            compiler,
            intersectionFunctionEntryPointName,
            intersectionFunctionBytecode,
            anyHitFunctionEntryPointName,
            anyHitFunctionBytecode,
            error,
        )
    }
    #[doc = " Copy the metallib binary, containing MetalIR bytecode.\n @param obj MetalIR object containing the bytecode from where to copy.\n @param stage shader stage to copy.\n @param lib metallib binary into which to copy the metallib.\n @return true if the metallib binary contains bytecode for this shader stage, false otherwise."]
    pub unsafe fn IRObjectGetMetalLibBinary(
        &self,
        obj: *const IRObject,
        stage: IRShaderStage,
        lib: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRObjectGetMetalLibBinary)(obj, stage, lib)
    }
    #[doc = " Configure whether the compiler should generate a Metal vertex fetch, or allow synthesizing a separate stage-in function.\n Use Metal vertex fetch to specify a MTLVertexDescriptor to your pipelines at runtime. Request a separate stage-in function to link vertex fetch as a Metal linked function.\n Using a separate stage-in function provides your shader with more flexitibility to perform type conversions, however, it requires more work to set up.\n @param compiler compiler to configure.\n @param stageInCodeGenerationMode code generation mode for the stage-in function."]
    pub unsafe fn IRCompilerSetStageInGenerationMode(
        &self,
        compiler: *mut IRCompiler,
        stageInCodeGenerationMode: IRStageInCodeGenerationMode,
    ) {
        (self.IRCompilerSetStageInGenerationMode)(compiler, stageInCodeGenerationMode)
    }
    #[doc = " Synthesize a stage in function.\n @param compiler compiler configuration to use.\n @param vertexShaderReflection reflection object of a vertex stage containing the inputs used as a base for synthesis.\n @param layout vertex input layout descriptor.\n @param binary pointer to a binary into which to write the synthesized MetalIR.\n @return true if the stageIn function could be successfully created, false otherwise."]
    pub unsafe fn IRMetalLibSynthesizeStageInFunction(
        &self,
        compiler: *const IRCompiler,
        vertexShaderReflection: *const IRShaderReflection,
        layout: *const IRVersionedInputLayoutDescriptor,
        binary: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRMetalLibSynthesizeStageInFunction)(compiler, vertexShaderReflection, layout, binary)
    }
    #[doc = " Copy reflection data stemming from the process of compiling DXIL to MetalIR.\n @param obj MetalIR object containing the metadata to copy.\n @param stage shader stage from where to obtain the reflection.\n @param reflection reflection object into which to copy the reflection data.\n @return true if the metallib binary contains bytecode for this shader stage, false otherwise."]
    pub unsafe fn IRObjectGetReflection(
        &self,
        obj: *const IRObject,
        stage: IRShaderStage,
        reflection: *mut IRShaderReflection,
    ) -> bool {
        (self.IRObjectGetReflection)(obj, stage, reflection)
    }
    #[doc = " Configure a compiler to emit a shader that consumes a top-level Argument Buffer layout matching a specific root signature.\n @param compiler compiler to configure.\n @param rootSignature root signature that defines the layout of the top-level Argument Buffer for any shaders you compile with this compiler.\n Pass in NULL (the default) to have the compiler generate a linear resource layout instead. If you provide a non-NULL rootSignature, you must ensure it is not destroyed before the compiler."]
    pub unsafe fn IRCompilerSetGlobalRootSignature(
        &self,
        compiler: *mut IRCompiler,
        rootSignature: *const IRRootSignature,
    ) {
        (self.IRCompilerSetGlobalRootSignature)(compiler, rootSignature)
    }
    #[doc = " Configure a compiler to produce a shader that consumes a local root signature matching a specific layout.\n @param compiler compiler to configure.\n @param rootSignature If you provide a non-NULL rootSignature, you must ensure it is not destroyed before the compiler."]
    pub unsafe fn IRCompilerSetLocalRootSignature(
        &self,
        compiler: *mut IRCompiler,
        rootSignature: *const IRRootSignature,
    ) {
        (self.IRCompilerSetLocalRootSignature)(compiler, rootSignature)
    }
    #[doc = " Configure the hit group type for all subsequent shaders a compiler compiles.\n @param compiler compiler to configure\n @param hitGroupType type of hitgroup the shader expects"]
    pub unsafe fn IRCompilerSetHitgroupType(
        &self,
        compiler: *mut IRCompiler,
        hitGroupType: IRHitGroupType,
    ) {
        (self.IRCompilerSetHitgroupType)(compiler, hitGroupType)
    }
    #[doc = " Analyze an input IR and produce a mask representing all ray tracing intrinsics it references.\n Use this function to gather all intrinsics for your closest hit, any hit, intersection, and callable shaders and produce optimal hit group arguments."]
    pub unsafe fn IRObjectGatherRaytracingIntrinsics(
        &self,
        input: *mut IRObject,
        entryPoint: *const ::std::os::raw::c_char,
    ) -> u64 {
        (self.IRObjectGatherRaytracingIntrinsics)(input, entryPoint)
    }
    #[doc = " Configure a compiler with upfront information to generate an optimal interface between ray tracing functions.\n Calling this function is optional, but when omitted, the compiler needs to assume a worst-case scenario, significantly affecting runtime performance.\n Use function `IRObjectGatherRaytracingIntrinsics` to collect the intrinsic usage mask for all closest hit, any hit, intersection, and callable shaders in the pipeline to build.\n After calling this function, all subsequent shaders compiled need to conform to the masks provided, otherwise undefined behavior occurs.\n Specifying a mask and then adding additional shaders to a pipeline that don't conform to it causes undefined behavior.\n @param compiler compiler to configure\n @param maxAttributeSizeInBytes the maximum number of ray tracing attributes (in bytes) that a pipeline consisting of these shaders uses.\n @param raytracingPipelineFlags flags for the ray tracing pipeline your application builds from these shaders.\n @param chs bitwise OR mask of all closest hit shaders for a ray tracing pipeline your application builds using subsequent converted shaders (defaults to `IRIntrinsicMaskClosestHitAll`).\n @param miss bitwise OR mask of all miss shaders for a ray tracing pipeline your application builds using subsequent converted shaders (defaults to `IRIntrinsicMaskMissShaderAll`).\n @param anyHit bitwise OR mask of all any hit shaders for a ray tracing pipeline your application builds using subsequent converted shaders (defaults to `IRIntrinsicMaskAnyHitShaderAll`).\n @param callableArgs bitwise OR mask of all callable shaders for a ray tracing pipeline your application builds using subsequent converted shaders (defaults to `IRIntrinsicMaskCallableShaderAll`).\n @param maxRecursiveDepth stop point for recursion. Pass `IRRayTracingUnlimitedRecursionDepth` for no limit.\n @warning providing mask values other than the defaults or those returned by `IRObjectGatherRaytracingIntrinsics` may cause subsequent shader compilations to fail."]
    pub unsafe fn IRCompilerSetRayTracingPipelineArguments(
        &self,
        compiler: *mut IRCompiler,
        maxAttributeSizeInBytes: u32,
        raytracingPipelineFlags: IRRaytracingPipelineFlags,
        chs: u64,
        miss: u64,
        anyHit: u64,
        callableArgs: u64,
        maxRecursiveDepth: ::std::os::raw::c_int,
    ) {
        (self.IRCompilerSetRayTracingPipelineArguments)(
            compiler,
            maxAttributeSizeInBytes,
            raytracingPipelineFlags,
            chs,
            miss,
            anyHit,
            callableArgs,
            maxRecursiveDepth,
        )
    }
    #[doc = " Configure compiler compatibility flags.\n Compatibility flags allow you to tailor code generation to the specific requirements of your shaders.\n You typically enable compatibility flags to support a broader set of features and behaviors (such as out-of-bounds reads) when your shader needs them to operate correctly.\n These flags, however, carry a performance cost.\n Always use the minimum set of compatibility flags your shader needs to attain the highest runtime performance for IR code you compile.\n @param compiler the compiler to configure\n @param flags bitmask of compatibility flags to enable."]
    pub unsafe fn IRCompilerSetCompatibilityFlags(
        &self,
        compiler: *mut IRCompiler,
        flags: IRCompatibilityFlags,
    ) {
        (self.IRCompilerSetCompatibilityFlags)(compiler, flags)
    }
    #[doc = " Set primitive input topology\n Provides the compiler with information about input topology this shader will be used with.\n This information is required to correctly compile shaders that will render point primitive and may be used for other optimizations.\n @param compiler the compiler to configure\n @param inputTopology input topology"]
    pub unsafe fn IRCompilerSetInputTopology(
        &self,
        compiler: *mut IRCompiler,
        inputTopology: IRInputTopology,
    ) {
        (self.IRCompilerSetInputTopology)(compiler, inputTopology)
    }
    #[doc = " Enable geometry and tessellation emulation.\n @param compiler compiler to configure with geometry and tessellation emulation.\n @param enable pass in true to enable geometry and tessellation emulation, false to disable it."]
    pub unsafe fn IRCompilerEnableGeometryAndTessellationEmulation(
        &self,
        compiler: *mut IRCompiler,
        enable: bool,
    ) {
        (self.IRCompilerEnableGeometryAndTessellationEmulation)(compiler, enable)
    }
    #[doc = " Enable dual-source blending support.\n When the configuration parameter is set to `IRDualSourceBlendingConfigurationDecideAtRuntime`, you must provide a function constant named \"`dualSourceBlendingEnabled`\" of type `uint8_t` at\n pipeline creation time, specifying whether to enable dual source blending.\n @param compiler compiler to configure.\n @param configuration set to enabled or disable to enable and disable support. Set to decide-at-runtime to control support at PSO-creation time via function constants.\n This parameter is reset after each compilation."]
    pub unsafe fn IRCompilerSetDualSourceBlendingConfiguration(
        &self,
        compiler: *mut IRCompiler,
        configuration: IRDualSourceBlendingConfiguration,
    ) {
        (self.IRCompilerSetDualSourceBlendingConfiguration)(compiler, configuration)
    }
    #[doc = " Enable depth feedback support.\n When the configuration parameter is set to `IRDepthWriteConfigurationDecideAtRuntime`, you must provide a function constant named \"`depthFeedbackEnabled`\" of type `uint8_t` at\n pipeline creation time, specifying whether to enable depth feedback.\n @param compiler compiler to configure.\n @param configuration set to enabled or disable to enable and disable support. Set to decide-at-runtime to control support at PSO-creation time via function constants.\n This parameter is reset after each compilation."]
    pub unsafe fn IRCompilerSetDepthFeedbackConfiguration(
        &self,
        compiler: *mut IRCompiler,
        configuration: IRDepthFeedbackConfiguration,
    ) {
        (self.IRCompilerSetDepthFeedbackConfiguration)(compiler, configuration)
    }
    #[doc = " Set Int compatible render target mask.\n Inform the compiler if the underlying render target is int compatible or not. The compiler will inject appropriate bitcast.\n @param compiler compiler to configure.\n @param intRTMask bitmask for each render target - 0 means that the RT is float compatible - 1 means that the RT is int compatible\n This parameter is reset after each compilation."]
    pub unsafe fn IRCompilerSetIntRTMask(&self, compiler: *mut IRCompiler, intRTMask: u8) {
        (self.IRCompilerSetIntRTMask)(compiler, intRTMask)
    }
    #[doc = " Synthesize an ray dispatch function that indirectly dispatches ray generation shaders.\n @param compiler compiler configuration to use.\n @param binary pointer to a binary into which to write the synthesized MetalIR.\n @return true if the intersection function could be successfully synthesized, false otherwise."]
    pub unsafe fn IRMetalLibSynthesizeIndirectRayDispatchFunction(
        &self,
        compiler: *const IRCompiler,
        binary: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRMetalLibSynthesizeIndirectRayDispatchFunction)(compiler, binary)
    }
    #[doc = " Synthesize a Metal ray tracing intersection function that calls into a visible function representing\n a custom intersection function.\n @param compiler compiler configuration to use. Current hit group and ray tracing configuration influences code generation.\n @param binary pointer to a binary into which to write the synthesized MetalIR.\n @return true if the intersection function could be successfully synthesized, false otherwise."]
    pub unsafe fn IRMetalLibSynthesizeIndirectIntersectionFunction(
        &self,
        compiler: *const IRCompiler,
        binary: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRMetalLibSynthesizeIndirectIntersectionFunction)(compiler, binary)
    }
    #[doc = " Customize the name of the entry point functions generated by a compiler.\n @param compiler compiler to configure.\n @param newName name IRConverter assigns to the emited entry point."]
    pub unsafe fn IRCompilerSetEntryPointName(
        &self,
        compiler: *mut IRCompiler,
        newName: *const ::std::os::raw::c_char,
    ) {
        (self.IRCompilerSetEntryPointName)(compiler, newName)
    }
    #[doc = " Set the minimum GPU deployment target for MetalIR code generation.\n Targetting a newer family may enable the compiler to emit MetalIR further optimized for newer GPUs, but may render it incompatible with older models.\n @param compiler compiler to configure.\n @param family minimum GPU family supported by code generation."]
    pub unsafe fn IRCompilerSetMinimumGPUFamily(
        &self,
        compiler: *mut IRCompiler,
        family: IRGPUFamily,
    ) {
        (self.IRCompilerSetMinimumGPUFamily)(compiler, family)
    }
    #[doc = " Set compiler settings to ignore root signature when needed\n @param compiler compiler for which to set the flags.\n @param ignoreEmbeddedRootSignature whether embeddedRootSignature should be ignored"]
    pub unsafe fn IRCompilerIgnoreRootSignature(
        &self,
        compiler: *mut IRCompiler,
        ignoreEmbeddedRootSignature: bool,
    ) {
        (self.IRCompilerIgnoreRootSignature)(compiler, ignoreEmbeddedRootSignature)
    }
    #[doc = " Set the minimum operating system software version target for Metal IR code generation.\n Targetting a newer software version may enable the compiler to emi MetalIR further optimized for newer macOS and iOS releases, but it may render it incompatible with older operating system versions.\n Setting a minimum deployment target newer than your SDK may produce an `IRErrorCodeUnableToLinkModule` error.\n @param compiler compiler to configure.\n @param operatingSystem operating system name.\n @param version operating system version, such as \"13.0.0\" or \"16.0.0\"."]
    pub unsafe fn IRCompilerSetMinimumDeploymentTarget(
        &self,
        compiler: *mut IRCompiler,
        operatingSystem: IROperatingSystem,
        version: *const ::std::os::raw::c_char,
    ) {
        (self.IRCompilerSetMinimumDeploymentTarget)(compiler, operatingSystem, version)
    }
    #[doc = " Create an empty metallib binary.\n @return a new, empty metallib binary."]
    pub unsafe fn IRMetalLibBinaryCreate(&self) -> *mut IRMetalLibBinary {
        (self.IRMetalLibBinaryCreate)()
    }
    #[doc = " Destroy a metallib binary.\n @param lib library to destroy."]
    pub unsafe fn IRMetalLibBinaryDestroy(&self, lib: *mut IRMetalLibBinary) {
        (self.IRMetalLibBinaryDestroy)(lib)
    }
    #[doc = " Copy the bytecode from a metallib library into a byte array.\n @param lib metallib library from where to copy the bytecode.\n @param outBytecode into which to write the bytecode. This parameter must be an array of at least IRMetalLibGetBytecodeSize bytes.\n @return number of bytes written."]
    pub unsafe fn IRMetalLibGetBytecode(
        &self,
        lib: *const IRMetalLibBinary,
        outBytecode: *mut u8,
    ) -> usize {
        (self.IRMetalLibGetBytecode)(lib, outBytecode)
    }
    #[doc = " Obtain the number of bytes needed to store the bytecode in a metallib.\n @param lib metallib to query.\n @return size in bytes needed to store the metallib's bytecode."]
    pub unsafe fn IRMetalLibGetBytecodeSize(&self, lib: *const IRMetalLibBinary) -> usize {
        (self.IRMetalLibGetBytecodeSize)(lib)
    }
    #[doc = " Serialize an MetalIR object's shader bytecode to disk.\n @param outputPath path into which to write the serialized MetalIR.\n @param obj IRObject containing the bytecode to serialize.\n @param stage shader stage to serialize."]
    pub unsafe fn IRObjectSerialize(
        &self,
        outputPath: *const ::std::os::raw::c_char,
        obj: *const IRObject,
        stage: IRShaderStage,
    ) -> bool {
        (self.IRObjectSerialize)(outputPath, obj, stage)
    }
    #[doc = " Create an empty reflection object.\n @return a new empty reflection object."]
    pub unsafe fn IRShaderReflectionCreate(&self) -> *mut IRShaderReflection {
        (self.IRShaderReflectionCreate)()
    }
    #[doc = " Release a reflection object.\n @param reflection reflection object to release."]
    pub unsafe fn IRShaderReflectionDestroy(&self, reflection: *mut IRShaderReflection) {
        (self.IRShaderReflectionDestroy)(reflection)
    }
    #[doc = " Obtain the name of the entry point from a reflection object.\n @return pointer to the name of the entry point. Do not free this pointer, its lifecycle is managed by, and coincides with, the reflection object's."]
    pub unsafe fn IRShaderReflectionGetEntryPointFunctionName(
        &self,
        reflection: *const IRShaderReflection,
    ) -> *const ::std::os::raw::c_char {
        (self.IRShaderReflectionGetEntryPointFunctionName)(reflection)
    }
    #[doc = " Determine whether the shader requires supplemental information to operate correctly.\n @param reflection reflection object to evaluate.\n @return true if the compiled shader requires supplemental information in the form of function constants, false otherwise."]
    pub unsafe fn IRShaderReflectionNeedsFunctionConstants(
        &self,
        reflection: *const IRShaderReflection,
    ) -> bool {
        (self.IRShaderReflectionNeedsFunctionConstants)(reflection)
    }
    #[doc = " Obtain the number of function constants in the reflection object.\n @param reflection reflection object to query.\n @return function constant count. May be zero if the shader stage to which this reflection corresponds has no function constants."]
    pub unsafe fn IRShaderReflectionGetFunctionConstantCount(
        &self,
        reflection: *const IRShaderReflection,
    ) -> usize {
        (self.IRShaderReflectionGetFunctionConstantCount)(reflection)
    }
    #[doc = " Copy function constant reflection data from a reflection object to an array.\n You are responsible for calling IRShaderReflectionReleaseFunctionConstants on the array to ensure copied function constant reflection data are released.\n @param reflection reflection object to query.\n @param functionConstants function constants array into which to write the reflection data. This object needs to be able to store at least\n IRShaderReflectionFunctionConstantCount function constants."]
    pub unsafe fn IRShaderReflectionCopyFunctionConstants(
        &self,
        reflection: *const IRShaderReflection,
        functionConstants: *mut IRFunctionConstant,
    ) {
        (self.IRShaderReflectionCopyFunctionConstants)(reflection, functionConstants)
    }
    #[doc = " Release function constant data.\n @param functionConstants array of function constants.\n @param functionConstantCount number of function constants in the array."]
    pub unsafe fn IRShaderReflectionReleaseFunctionConstants(
        &self,
        functionConstants: *mut IRFunctionConstant,
        functionConstantCount: usize,
    ) {
        (self.IRShaderReflectionReleaseFunctionConstants)(functionConstants, functionConstantCount)
    }
    #[doc = " Copy shader reflection for a compute stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param csinfo pointer to a versioned CS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseComputeInfo.\n @return true if the reflection object contains compute reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyComputeInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyComputeInfo)(reflection, version, csinfo)
    }
    #[doc = " Copy shader reflection for a vertex stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param vsinfo pointer to a versioned VS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseVertexInfo.\n @return true if the reflection object contains vertex stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyVertexInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyVertexInfo)(reflection, version, vsinfo)
    }
    #[doc = " Copy shader reflection for a fragment stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param fsinfo pointer to a versioned FS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseFragmentInfo.\n @return true if the reflection object contains fragment stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyFragmentInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyFragmentInfo)(reflection, version, fsinfo)
    }
    #[doc = " Copy shader reflection for a geometry stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param gsinfo pointer to a versioned GS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseGeometryInfo.\n @return true if the reflection object contains geometry stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyGeometryInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyGeometryInfo)(reflection, version, gsinfo)
    }
    #[doc = " Copy shader reflection for a hull shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param hsinfo pointer to a versioned HS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseHullInfo.\n @return true if the reflection object contains hull shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyHullInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        hsinfo: *mut IRVersionedHSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyHullInfo)(reflection, version, hsinfo)
    }
    #[doc = " Copy shader reflection for a domain shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param dsinfo pointer to a versioned DS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseDomainInfo.\n @return true if the reflection object contains domain shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyDomainInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyDomainInfo)(reflection, version, dsinfo)
    }
    #[doc = " Copy shader reflection for a mesh shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param msinfo pointer to a versioned MS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseMeshInfo.\n @return true if the reflection object contains domain shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyMeshInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        msinfo: *mut IRVersionedMSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyMeshInfo)(reflection, version, msinfo)
    }
    #[doc = " Copy shader reflection for an amplification shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param asinfo pointer to a versioned AS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseAmplificationInfo.\n @return true if the reflection object contains domain shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyAmplificationInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        asinfo: *mut IRVersionedASInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyAmplificationInfo)(reflection, version, asinfo)
    }
    #[doc = " Copy shader reflection for a ray tracing shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param rtinfo pointer to a versioned RT Info struct into which to copy the reflection data for the stage.  You must release the contents of this struct by calling IRShaderReflectionReleaseRaytracingInfo.\n @return true if the reflection object contains reflection for a ray tracing stage for the specified version."]
    pub unsafe fn IRShaderReflectionCopyRaytracingInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        rtinfo: *mut IRVersionedRTInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyRaytracingInfo)(reflection, version, rtinfo)
    }
    #[doc = " Release versioned compute information.\n @param csinfo pointer to the compute shader reflection information to release.\n @return false if the csinfo version is an unrecognized version or the csinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseComputeInfo(
        &self,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseComputeInfo)(csinfo)
    }
    #[doc = " Release versioned vertex stage information.\n @param vsinfo pointer to the vertex shader reflection information to release.\n @return false if the vsinfo version is an unrecognized version or the vsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseVertexInfo(
        &self,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseVertexInfo)(vsinfo)
    }
    #[doc = " Release versioned fragment stage information.\n @param fsinfo pointer to the fragment shader reflection information to release.\n @return false if the fsinfo version is an unrecognized version or the fsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseFragmentInfo(
        &self,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseFragmentInfo)(fsinfo)
    }
    #[doc = " Release versioned geometry stage information.\n @param gsinfo pointer to the geometry shader reflection information to release.\n @return false if the gsinfo version is an unrecognized version or the gsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseGeometryInfo(
        &self,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseGeometryInfo)(gsinfo)
    }
    #[doc = " Release versioned hull stage information.\n @param hsinfo pointer to the hull shader reflection information to release.\n @return false if the hsinfo version is an unrecognized version or the hsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseHullInfo(&self, hsinfo: *mut IRVersionedHSInfo) -> bool {
        (self.IRShaderReflectionReleaseHullInfo)(hsinfo)
    }
    #[doc = " Release versioned domain stage information.\n @param dsinfo pointer to the domain shader reflection information to release.\n @return false if the dsinfo version is an unrecognized version or the dsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseDomainInfo(
        &self,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseDomainInfo)(dsinfo)
    }
    #[doc = " Release versioned mesh stage information.\n @param msinfo pointer to the mesh shader reflection information to release.\n @return false if the msinfo version is an unrecognized version or the msinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseMeshInfo(&self, msinfo: *mut IRVersionedMSInfo) -> bool {
        (self.IRShaderReflectionReleaseMeshInfo)(msinfo)
    }
    #[doc = " Release versioned amplification stage information.\n @param asinfo pointer to the amplification shader reflection information to release.\n @return false if the asinfo version is an unrecognized version or the asinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseAmplificationInfo(
        &self,
        asinfo: *mut IRVersionedASInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseAmplificationInfo)(asinfo)
    }
    #[doc = " Release versioned ray tracing stage information.\n @param rtinfo pointer to the ray tracing shader reflection information to release.\n @return false if the rtinfo version is an unrecognized version or the rtinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseRaytracingInfo(
        &self,
        rtinfo: *mut IRVersionedRTInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseRaytracingInfo)(rtinfo)
    }
    #[doc = " Obtain the number of resources referenced by the top-level argument buffer\n @param reflection the reflection object for which to obtain the resource count.\n @return number of resources the top-level argument buffer references."]
    pub unsafe fn IRShaderReflectionGetResourceCount(
        &self,
        reflection: *const IRShaderReflection,
    ) -> usize {
        (self.IRShaderReflectionGetResourceCount)(reflection)
    }
    #[doc = " Get the locations within the top-level Argument Buffer for all top-level resources.\n @param reflection the reflection object resulting from the compilation process.\n @param resourceLocations parameter into which to write resource locations. This array must contain enough storage to write IRShaderReflectionGetResourceCount() elements.\n @note string references within the resource locations are pointers into the reflection object. The reflection object's lifecycle must be preserved while accessing these strings. Names may be NULL."]
    pub unsafe fn IRShaderReflectionGetResourceLocations(
        &self,
        reflection: *const IRShaderReflection,
        resourceLocations: *mut IRResourceLocation,
    ) {
        (self.IRShaderReflectionGetResourceLocations)(reflection, resourceLocations)
    }
    #[doc = " Obtain the number of resources referenced in a top-level Argument Buffer using a hierarchical layout.\n @param rootSignature root signature corresponding to the hierarchical layout definition.\n @return number of resources the top-level argument buffer references."]
    pub unsafe fn IRRootSignatureGetResourceCount(
        &self,
        rootSignature: *const IRRootSignature,
    ) -> usize {
        (self.IRRootSignatureGetResourceCount)(rootSignature)
    }
    #[doc = " Get the locations of resources in the top-level Argument Buffer.\n @param rootSignature root signature corresponding to the hierarchical layout definition.\n @param resourceLocations parameter into which to write resource locations. This array must contain enough storage to write IRRootSignatureGetResourceCount() elements."]
    pub unsafe fn IRRootSignatureGetResourceLocations(
        &self,
        rootSignature: *const IRRootSignature,
        resourceLocations: *mut IRResourceLocation,
    ) {
        (self.IRRootSignatureGetResourceLocations)(rootSignature, resourceLocations)
    }
    #[doc = " Serialize reflection information into JSON.\n @param reflection reflection object.\n @return null-terminated string containing JSON. You need to release this string by calling IRShaderReflectionFreeString."]
    pub unsafe fn IRShaderReflectionAllocStringAndSerialize(
        &self,
        reflection: *mut IRShaderReflection,
    ) -> *const ::std::os::raw::c_char {
        (self.IRShaderReflectionAllocStringAndSerialize)(reflection)
    }
    #[doc = " Release a string allocated by IRShaderReflectionAllocStringAndSerialize.\n @param serialized string to release."]
    pub unsafe fn IRShaderReflectionFreeString(&self, serialized: *const ::std::os::raw::c_char) {
        (self.IRShaderReflectionFreeString)(serialized)
    }
    #[doc = " Deserialize a JSON string into a reflection object.\n @param blob null-terminated JSON string containing reflection information.\n @param reflection reflection object into which to deserialize."]
    pub unsafe fn IRShaderReflectionDeserialize(
        &self,
        blob: *const ::std::os::raw::c_char,
        reflection: *mut IRShaderReflection,
    ) {
        (self.IRShaderReflectionDeserialize)(blob, reflection)
    }
    #[doc = " Serialize a root signature descriptor into a string representation.\n @param rootSignatureDescriptor root signature descriptor to serialize.\n @return a string representation of the root signature descriptor. You need to release this string by calling IRVersionedRootSignatureDescriptorFreeString."]
    pub unsafe fn IRVersionedRootSignatureDescriptorAllocStringAndSerialize(
        &self,
        rootSignatureDescriptor: *mut IRVersionedRootSignatureDescriptor,
    ) -> *const ::std::os::raw::c_char {
        (self.IRVersionedRootSignatureDescriptorAllocStringAndSerialize)(rootSignatureDescriptor)
    }
    #[doc = " Release a string allocated by IRVersionedRootSignatureDescriptorAllocStringAndSerialize.\n @param serialized string to release."]
    pub unsafe fn IRVersionedRootSignatureDescriptorFreeString(
        &self,
        serialized: *const ::std::os::raw::c_char,
    ) {
        (self.IRVersionedRootSignatureDescriptorFreeString)(serialized)
    }
    #[doc = " Deserialized a string representation of a root signature into a root signature object.\n @param serialized a string representation of a root signature.\n @param rootSignatureDescriptor root signature object into which to deserialize the root signature.\n @return true if deserialization is successful, false otherwise."]
    pub unsafe fn IRVersionedRootSignatureDescriptorDeserialize(
        &self,
        serialized: *const ::std::os::raw::c_char,
        rootSignatureDescriptor: *mut IRVersionedRootSignatureDescriptor,
    ) -> bool {
        (self.IRVersionedRootSignatureDescriptorDeserialize)(serialized, rootSignatureDescriptor)
    }
}
