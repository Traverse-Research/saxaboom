/* automatically generated by rust-bindgen 0.65.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const IR_VERSION_MAJOR: u32 = 0;
pub const IR_VERSION_MINOR: u32 = 1;
pub const IR_VERSION_PATCH: u32 = 0;
pub const IRDescriptorRangeOffsetAppend: u32 = 4294967295;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRError {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRCompiler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRMetalLibBinary {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRShaderReflection {
    _unused: [u8; 0],
}
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
pub type __vcrt_bool = bool;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRComparisonFunction {
    IRComparisonFunctionNever = 1,
    IRComparisonFunctionLess = 2,
    IRComparisonFunctionEqual = 3,
    IRComparisonFunctionLessEqual = 4,
    IRComparisonFunctionGreater = 5,
    IRComparisonFunctionNotEqual = 6,
    IRComparisonFunctionGreaterEqual = 7,
    IRComparisonFunctionAlways = 8,
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagNone: IRDescriptorRangeFlags = IRDescriptorRangeFlags(0);
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagDescriptorsVolatile: IRDescriptorRangeFlags =
        IRDescriptorRangeFlags(1);
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagDataVolatile: IRDescriptorRangeFlags = IRDescriptorRangeFlags(2);
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagDataStaticWhileSetAtExecute: IRDescriptorRangeFlags =
        IRDescriptorRangeFlags(4);
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagDataStatic: IRDescriptorRangeFlags = IRDescriptorRangeFlags(8);
}
impl IRDescriptorRangeFlags {
    pub const IRDescriptorRangeFlagDescriptorsStaticKeepingBufferBoundsChecks:
        IRDescriptorRangeFlags = IRDescriptorRangeFlags(65536);
}
impl ::std::ops::BitOr<IRDescriptorRangeFlags> for IRDescriptorRangeFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRDescriptorRangeFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRDescriptorRangeFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRDescriptorRangeFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRDescriptorRangeFlags> for IRDescriptorRangeFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRDescriptorRangeFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRDescriptorRangeFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRDescriptorRangeFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRDescriptorRangeFlags(pub ::std::os::raw::c_int);
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFilter {
    IRFilterMinMagMipPoint = 0,
    IRFilterMinMagPointMipLinear = 1,
    IRFilterMinPointMagLinearMipPoint = 4,
    IRFilterMinPointMagMipLinear = 5,
    IRFilterMinLinearMagMipPoint = 16,
    IRFilterMinLinearMagPointMipLinear = 17,
    IRFilterMinMagLinearMipPoint = 20,
    IRFilterMinMagMipLinear = 21,
    IRFilterAnisotropic = 85,
    IRFilterComparisonMinMagMipPoint = 128,
    IRFilterComparisonMinMagPointMipLinear = 129,
    IRFilterComparisonMinPointMagLinearMipPoint = 132,
    IRFilterComparisonMinPointMagMipLinear = 133,
    IRFilterComparisonMinLinearMagMipPoint = 144,
    IRFilterComparisonMinLinearMagPointMipLinear = 145,
    IRFilterComparisonMinMagLinearMipPoint = 148,
    IRFilterComparisonMinMagMipLinear = 149,
    IRFilterComparisonAnisotropic = 213,
    IRFilterMinimumMinMagMipPoint = 256,
    IRFilterMinimumMinMagPointMipLinear = 257,
    IRFilterMinimumMinPointMagLinearMipPoint = 260,
    IRFilterMinimumMinPointMagMipLinear = 261,
    IRFilterMinimumMinLinearMagMipPoint = 272,
    IRFilterMinimumMinLinearMagPointMipLinear = 273,
    IRFilterMinimumMinMagLinearMipPoint = 276,
    IRFilterMinimumMinMagMipLinear = 277,
    IRFilterMinimumAnisotropic = 341,
    IRFilterMaximumMinMagMipPoint = 384,
    IRFilterMaximumMinMagPointMipLinear = 385,
    IRFilterMaximumMinPointMagLinearMipPoint = 388,
    IRFilterMaximumMinPointMagMipLinear = 389,
    IRFilterMaximumMinLinearMagMipPoint = 400,
    IRFilterMaximumMinLinearMagPointMipLinear = 401,
    IRFilterMaximumMinMagLinearMipPoint = 404,
    IRFilterMaximumMinMagMipLinear = 405,
    IRFilterMaximumAnisotropic = 469,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFormat {
    IRFormatUnknown = 0,
    IRFormatR32G32B32A32Typeless = 1,
    IRFormatR32G32B32A32Float = 2,
    IRFormatR32G32B32A32Uint = 3,
    IRFormatR32G32B32A32Sint = 4,
    IRFormatR32G32B32Typeless = 5,
    IRFormatR32G32B32Float = 6,
    IRFormatR32G32B32Uint = 7,
    IRFormatR32G32B32Sint = 8,
    IRFormatR16G16B16A16Typeless = 9,
    IRFormatR16G16B16A16Float = 10,
    IRFormatR16G16B16A16Unorm = 11,
    IRFormatR16G16B16A16Uint = 12,
    IRFormatR16G16B16A16Snorm = 13,
    IRFormatR16G16B16A16Sint = 14,
    IRFormatR32G32Typeless = 15,
    IRFormatR32G32Float = 16,
    IRFormatR32G32Uint = 17,
    IRFormatR32G32Sint = 18,
    IRFormatR32G8X24Typeless = 19,
    IRFormatD32FloatS8X24Uint = 20,
    IRFormatR32FloatX8X24Typeless = 21,
    IRFormatX32TypelessG8X24Uint = 22,
    IRFormatR10G10B10A2Typeless = 23,
    IRFormatR10G10B10A2Unorm = 24,
    IRFormatR10G10B10A2Uint = 25,
    IRFormatR11G11B10Float = 26,
    IRFormatR8G8B8A8Typeless = 27,
    IRFormatR8G8B8A8Unorm = 28,
    IRFormatR8G8B8A8Unorm_sRGB = 29,
    IRFormatR8G8B8A8Uint = 30,
    IRFormatR8G8B8A8Snorm = 31,
    IRFormatR8G8B8A8Sint = 32,
    IRFormatR16G16Typeless = 33,
    IRFormatR16G16Float = 34,
    IRFormatR16G16Unorm = 35,
    IRFormatR16G16Uint = 36,
    IRFormatR16G16Snorm = 37,
    IRFormatR16G16Sint = 38,
    IRFormatR32Typeless = 39,
    IRFormatD32Float = 40,
    IRFormatR32Float = 41,
    IRFormatR32Uint = 42,
    IRFormatR32Sint = 43,
    IRFormatR24G8Typeless = 44,
    IRFormatD24UnormS8Uint = 45,
    IRFormatR24UnormX8Typeless = 46,
    IRFormatX24TypelessG8Uint = 47,
    IRFormatR8G8Typeless = 48,
    IRFormatR8G8Unorm = 49,
    IRFormatR8G8Uint = 50,
    IRFormatR8G8Snorm = 51,
    IRFormatR8G8Sint = 52,
    IRFormatR16Typeless = 53,
    IRFormatR16Float = 54,
    IRFormatD16Unorm = 55,
    IRFormatR16Unorm = 56,
    IRFormatR16Uint = 57,
    IRFormatR16Snorm = 58,
    IRFormatR16Sint = 59,
    IRFormatR8Typeless = 60,
    IRFormatR8Unorm = 61,
    IRFormatR8Uint = 62,
    IRFormatR8Snorm = 63,
    IRFormatR8Sint = 64,
    IRFormatA8Unorm = 65,
    IRFormatR1Unorm = 66,
    IRFormatR9G9B9E5Sharedexp = 67,
    IRFormatR8G8B8G8Unorm = 68,
    IRFormatG8R8G8B8Unorm = 69,
    IRFormatBC1Typeless = 70,
    IRFormatBC1Unorm = 71,
    IRFormatBC1Unorm_sRGB = 72,
    IRFormatBC2Typeless = 73,
    IRFormatBC2Unorm = 74,
    IRFormatBC2Unorm_sRGB = 75,
    IRFormatBC3Typeless = 76,
    IRFormatBC3Unorm = 77,
    IRFormatBC3Unorm_sRGB = 78,
    IRFormatBC4Typeless = 79,
    IRFormatBC4Unorm = 80,
    IRFormatBC4Snorm = 81,
    IRFormatBC5Typeless = 82,
    IRFormatBC5Unorm = 83,
    IRFormatBC5Snorm = 84,
    IRFormatB5G6R5Unorm = 85,
    IRFormatB5G5R5A1Unorm = 86,
    IRFormatB8G8R8A8Unorm = 87,
    IRFormatB8G8R8X8Unorm = 88,
    IRFormatR10G10B10XRBiasA2Unorm = 89,
    IRFormatB8G8R8A8Typeless = 90,
    IRFormatB8G8R8A8Unorm_sRGB = 91,
    IRFormatB8G8R8X8Typeless = 92,
    IRFormatB8G8R8X8Unorm_sRGB = 93,
    IRFormatBC6HTypeless = 94,
    IRFormatBC6HUf16 = 95,
    IRFormatBC6HSf16 = 96,
    IRFormatBC7Typeless = 97,
    IRFormatBC7Unorm = 98,
    IRFormatBC7Unorm_sRGB = 99,
    IRFormatAYUV = 100,
    IRFormatY410 = 101,
    IRFormatY416 = 102,
    IRFormatNV12 = 103,
    IRFormatP010 = 104,
    IRFormatP016 = 105,
    IRFormat420Opaque = 106,
    IRFormatYUY2 = 107,
    IRFormatY210 = 108,
    IRFormatY216 = 109,
    IRFormatNV11 = 110,
    IRFormatAI44 = 111,
    IRFormatIA44 = 112,
    IRFormatP8 = 113,
    IRFormatA8P8 = 114,
    IRFormatB4G4R4A4Unorm = 115,
    IRFormatP208 = 130,
    IRFormatV208 = 131,
    IRFormatV408 = 132,
    IRFormatSamplerFeedbackMinMipOpaque = 189,
    IRFormatSamplerFeedbackMipRegionUsedOpaque = 190,
    IRFormatForceUint = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputClassification {
    IRInputClassificationPerVertexData = 0,
    IRInputClassificationPerInstanceData = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputPrimitive {
    IRInputPrimitiveUndefined = 0,
    IRInputPrimitivePoint = 1,
    IRInputPrimitiveLine = 2,
    IRInputPrimitiveTriangle = 3,
    IRInputPrimitiveLineAdj = 6,
    IRInputPrimitiveTriangleAdj = 7,
    IRInputPrimitive1ControlPointPatch = 8,
    IRInputPrimitive2ControlPointPatch = 9,
    IRInputPrimitive3ControlPointPatch = 10,
    IRInputPrimitive4ControlPointPatch = 11,
    IRInputPrimitive5ControlPointPatch = 12,
    IRInputPrimitive6ControlPointPatch = 13,
    IRInputPrimitive7ControlPointPatch = 14,
    IRInputPrimitive8ControlPointPatch = 15,
    IRInputPrimitive9ControlPointPatch = 16,
    IRInputPrimitive10ControlPointPatch = 17,
    IRInputPrimitive11ControlPointPatch = 18,
    IRInputPrimitive12ControlPointPatch = 19,
    IRInputPrimitive13ControlPointPatch = 20,
    IRInputPrimitive14ControlPointPatch = 21,
    IRInputPrimitive15ControlPointPatch = 22,
    IRInputPrimitive16ControlPointPatch = 23,
    IRInputPrimitive17ControlPointPatch = 24,
    IRInputPrimitive18ControlPointPatch = 25,
    IRInputPrimitive19ControlPointPatch = 26,
    IRInputPrimitive20ControlPointPatch = 27,
    IRInputPrimitive21ControlPointPatch = 28,
    IRInputPrimitive22ControlPointPatch = 29,
    IRInputPrimitive23ControlPointPatch = 30,
    IRInputPrimitive24ControlPointPatch = 31,
    IRInputPrimitive25ControlPointPatch = 32,
    IRInputPrimitive26ControlPointPatch = 33,
    IRInputPrimitive27ControlPointPatch = 34,
    IRInputPrimitive28ControlPointPatch = 35,
    IRInputPrimitive29ControlPointPatch = 36,
    IRInputPrimitive30ControlPointPatch = 37,
    IRInputPrimitive31ControlPointPatch = 38,
    IRInputPrimitive32ControlPointPatch = 39,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputTopology {
    IRInputTopologyUndefined = 0,
    IRInputTopologyPoint = 1,
    IRInputTopologyLine = 2,
    IRInputTopologyTriangle = 3,
    IRInputTopologyPatch = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorOutputPrimitive {
    IRTessellatorOutputUndefined = 0,
    IRTessellatorOutputPoint = 1,
    IRTessellatorOutputLine = 2,
    IRTessellatorOutputTriangleCW = 3,
    IRTessellatorOutputTriangleCCW = 4,
}
impl IRRootDescriptorFlags {
    pub const IRRootDescriptorFlagNone: IRRootDescriptorFlags = IRRootDescriptorFlags(0);
}
impl IRRootDescriptorFlags {
    pub const IRRootDescriptorFlagDataVolatile: IRRootDescriptorFlags = IRRootDescriptorFlags(2);
}
impl IRRootDescriptorFlags {
    pub const IRRootDescriptorFlagDataStaticWhileSetAtExecute: IRRootDescriptorFlags =
        IRRootDescriptorFlags(4);
}
impl IRRootDescriptorFlags {
    pub const IRRootDescriptorFlagDataStatic: IRRootDescriptorFlags = IRRootDescriptorFlags(8);
}
impl ::std::ops::BitOr<IRRootDescriptorFlags> for IRRootDescriptorFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRRootDescriptorFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRRootDescriptorFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRRootDescriptorFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRRootDescriptorFlags> for IRRootDescriptorFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRRootDescriptorFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRRootDescriptorFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRRootDescriptorFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRRootDescriptorFlags(pub ::std::os::raw::c_int);
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagNone: IRRootSignatureFlags = IRRootSignatureFlags(0);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagAllowInputAssemblerInputLayout: IRRootSignatureFlags =
        IRRootSignatureFlags(1);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyVertexShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(2);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyHullShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(4);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyDomainShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(8);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyGeometryShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(16);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyPixelShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(32);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagAllowStreamOutput: IRRootSignatureFlags = IRRootSignatureFlags(64);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagLocalRootSignature: IRRootSignatureFlags =
        IRRootSignatureFlags(128);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyAmplificationShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(256);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagDenyMeshShaderRootAccess: IRRootSignatureFlags =
        IRRootSignatureFlags(512);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagCBVSRVUAVHeapDirectlyIndexed: IRRootSignatureFlags =
        IRRootSignatureFlags(1024);
}
impl IRRootSignatureFlags {
    pub const IRRootSignatureFlagSamplerHeapDirectlyIndexed: IRRootSignatureFlags =
        IRRootSignatureFlags(2048);
}
impl ::std::ops::BitOr<IRRootSignatureFlags> for IRRootSignatureFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRRootSignatureFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRRootSignatureFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRRootSignatureFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRRootSignatureFlags> for IRRootSignatureFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRRootSignatureFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRRootSignatureFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRRootSignatureFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRRootSignatureFlags(pub ::std::os::raw::c_int);
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRShaderVisibility {
    IRShaderVisibilityAll = 0,
    IRShaderVisibilityVertex = 1,
    IRShaderVisibilityHull = 2,
    IRShaderVisibilityDomain = 3,
    IRShaderVisibilityGeometry = 4,
    IRShaderVisibilityPixel = 5,
    IRShaderVisibilityAmplification = 6,
    IRShaderVisibilityMesh = 7,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorDomain {
    IRTessellatorDomainUndefined = 0,
    IRTessellatorDomainIsoline = 1,
    IRTessellatorDomainTri = 2,
    IRTessellatorDomainQuad = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTessellatorPartitioning {
    IRTessellatorPartitioningUndefined = 0,
    IRTessellatorPartitioningInteger = 1,
    IRTessellatorPartitioningPow2 = 2,
    IRTessellatorPartitioningFractionalOdd = 3,
    IRTessellatorPartitioningFractionalEven = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRTextureAddressMode {
    IRTextureAddressModeWrap = 1,
    IRTextureAddressModeMirror = 2,
    IRTextureAddressModeClamp = 3,
    IRTextureAddressModeBorder = 4,
    IRTextureAddressModeMirrorOnce = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRShaderStage {
    IRShaderStageInvalid = 0,
    IRShaderStageVertex = 1,
    IRShaderStageFragment = 2,
    IRShaderStageHull = 3,
    IRShaderStageDomain = 4,
    IRShaderStageMesh = 5,
    IRShaderStageAmplification = 6,
    IRShaderStageGeometry = 7,
    IRShaderStageCompute = 8,
    IRShaderStageClosestHit = 9,
    IRShaderStageIntersection = 10,
    IRShaderStageAnyHit = 11,
    IRShaderStageMiss = 12,
    IRShaderStageRayGeneration = 13,
    IRShaderStageCallable = 14,
    IRShaderStageStreamOut = 15,
    IRShaderStageStageIn = 16,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRObjectType {
    IRObjectTypeDXILBytecode = 0,
    IRObjectTypeMetalIRObject = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRResourceType {
    IRResourceTypeTable = 0,
    IRResourceTypeConstant = 1,
    IRResourceTypeCBV = 2,
    IRResourceTypeSRV = 3,
    IRResourceTypeUAV = 4,
    IRResourceTypeSampler = 5,
    IRResourceTypeInvalid = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDescriptorRangeType {
    IRDescriptorRangeTypeSRV = 0,
    IRDescriptorRangeTypeUAV = 1,
    IRDescriptorRangeTypeCBV = 2,
    IRDescriptorRangeTypeSampler = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDescriptorRange {
    pub RangeType: IRDescriptorRangeType,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub OffsetInDescriptorsFromTableStart: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptorTable {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const IRDescriptorRange,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexInputTable {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const IRDescriptorRange,
}
pub type IRVertexInput = IRVertexInputTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootConstants {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Num32BitValues: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptor {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStripCutIndex {
    IRStripCutIndexDisabled = 0,
    IRStripCutIndex0xFFFF = 1,
    IRStripCutIndex0xFFFFFFFF = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRRootParameterType {
    IRRootParameterTypeDescriptorTable = 0,
    IRRootParameterType32BitConstants = 1,
    IRRootParameterTypeCBV = 2,
    IRRootParameterTypeSRV = 3,
    IRRootParameterTypeUAV = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRRootParameter {
    pub ParameterType: IRRootParameterType,
    pub __bindgen_anon_1: IRRootParameter__bindgen_ty_1,
    pub ShaderVisibility: IRShaderVisibility,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRRootParameter__bindgen_ty_1 {
    pub DescriptorTable: IRRootDescriptorTable,
    pub Constants: IRRootConstants,
    pub Descriptor: IRRootDescriptor,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStaticBorderColor {
    IRStaticBorderColorTransparentBlack = 0,
    IRStaticBorderColorOpaqueBlack = 1,
    IRStaticBorderColorOpaqueWhite = 2,
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagNone: IRCompatibilityFlags = IRCompatibilityFlags(0);
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagBoundsCheck: IRCompatibilityFlags = IRCompatibilityFlags(1);
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagVertexPositionInfToNan: IRCompatibilityFlags =
        IRCompatibilityFlags(2);
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagTextureMinLODClamp: IRCompatibilityFlags = IRCompatibilityFlags(4);
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagSamplerLODBias: IRCompatibilityFlags = IRCompatibilityFlags(8);
}
impl IRCompatibilityFlags {
    pub const IRCompatibilityFlagPositionInvariance: IRCompatibilityFlags =
        IRCompatibilityFlags(16);
}
impl ::std::ops::BitOr<IRCompatibilityFlags> for IRCompatibilityFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRCompatibilityFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRCompatibilityFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRCompatibilityFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRCompatibilityFlags> for IRCompatibilityFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRCompatibilityFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRCompatibilityFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRCompatibilityFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRCompatibilityFlags(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRStaticSamplerDescriptor {
    pub Filter: IRFilter,
    pub AddressU: IRTextureAddressMode,
    pub AddressV: IRTextureAddressMode,
    pub AddressW: IRTextureAddressMode,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: IRComparisonFunction,
    pub BorderColor: IRStaticBorderColor,
    pub MinLOD: f32,
    pub MaxLOD: f32,
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub ShaderVisibility: IRShaderVisibility,
}
impl IRRootSignatureVersion {
    pub const IRRootSignatureVersion_1_0: IRRootSignatureVersion =
        IRRootSignatureVersion::IRRootSignatureVersion_1;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRRootSignatureVersion {
    IRRootSignatureVersion_1 = 1,
    IRRootSignatureVersion_1_1 = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignatureDescriptor {
    pub NumParameters: u32,
    pub pParameters: *const IRRootParameter,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const IRStaticSamplerDescriptor,
    pub Flags: IRRootSignatureFlags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDescriptorRange1 {
    pub RangeType: IRDescriptorRangeType,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: IRDescriptorRangeFlags,
    pub OffsetInDescriptorsFromTableStart: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptorTable1 {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const IRDescriptorRange1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootDescriptor1 {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: IRRootDescriptorFlags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRRootParameter1 {
    pub ParameterType: IRRootParameterType,
    pub __bindgen_anon_1: IRRootParameter1__bindgen_ty_1,
    pub ShaderVisibility: IRShaderVisibility,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRRootParameter1__bindgen_ty_1 {
    pub DescriptorTable: IRRootDescriptorTable1,
    pub Constants: IRRootConstants,
    pub Descriptor: IRRootDescriptor1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRRootSignatureDescriptor1 {
    pub NumParameters: u32,
    pub pParameters: *const IRRootParameter1,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const IRStaticSamplerDescriptor,
    pub Flags: IRRootSignatureFlags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedRootSignatureDescriptor {
    pub version: IRRootSignatureVersion,
    pub __bindgen_anon_1: IRVersionedRootSignatureDescriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedRootSignatureDescriptor__bindgen_ty_1 {
    pub desc_1_0: IRRootSignatureDescriptor,
    pub desc_1_1: IRRootSignatureDescriptor1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRInputElementDescriptor1 {
    pub semanticIndex: u32,
    pub format: IRFormat,
    pub inputSlot: u32,
    pub alignedByteOffset: u32,
    pub inputSlotClass: IRInputClassification,
    pub instanceDataStepRate: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRInputLayoutDescriptor1 {
    pub semanticNames: [*const ::std::os::raw::c_char; 31usize],
    pub inputElementDescs: [IRInputElementDescriptor1; 31usize],
    pub numElements: u32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRInputLayoutDescriptorVersion {
    IRInputLayoutDescriptorVersion_1 = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedInputLayoutDescriptor {
    pub version: IRInputLayoutDescriptorVersion,
    pub __bindgen_anon_1: IRVersionedInputLayoutDescriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedInputLayoutDescriptor__bindgen_ty_1 {
    pub desc_1_0: IRInputLayoutDescriptor1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRErrorCode {
    IRErrorCodeNoError = 0,
    IRErrorCodeShaderRequiresRootSignature = 1,
    IRErrorCodeUnrecognizedRootSignatureDescriptor = 2,
    IRErrorCodeUnrecognizedParameterTypeInRootSignature = 3,
    IRErrorCodeResourceNotReferencedByRootSignature = 4,
    IRErrorCodeShaderIncompatibleWithDualSourceBlending = 5,
    IRErrorCodeUnsupportedWaveSize = 6,
    IRErrorCodeUnsupportedInstruction = 7,
    IRErrorCodeCompilationError = 8,
    IRErrorCodeFailedToSynthesizeStageInFunction = 9,
    IRErrorCodeFailedToSynthesizeStreamOutFunction = 10,
    IRErrorCodeFailedToSynthesizeIntersectionWrapperFunction = 11,
    IRErrorCodeUnableToVerifyModule = 12,
    IRErrorCodeUnableToLinkModule = 13,
    IRErrorCodeUnknown = 14,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRBytecodeOwnership {
    #[doc = " Do not take ownership."]
    IRBytecodeOwnershipNone = 0,
    #[doc = " Copy the bytecode."]
    IRBytecodeOwnershipCopy = 1,
}
impl IRCompilerValidationFlags {
    pub const IRCompilerValidationFlagNone: IRCompilerValidationFlags =
        IRCompilerValidationFlags(0);
}
impl IRCompilerValidationFlags {
    pub const IRCompilerValidationFlagValidateRawRootResources: IRCompilerValidationFlags =
        IRCompilerValidationFlags(1);
}
impl IRCompilerValidationFlags {
    pub const IRCompilerValidationFlagValidateAllResourcesBound: IRCompilerValidationFlags =
        IRCompilerValidationFlags(2);
}
impl IRCompilerValidationFlags {
    pub const IRCompilerValidationFlagAll: IRCompilerValidationFlags =
        IRCompilerValidationFlags(-1);
}
impl ::std::ops::BitOr<IRCompilerValidationFlags> for IRCompilerValidationFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        IRCompilerValidationFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for IRCompilerValidationFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: IRCompilerValidationFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<IRCompilerValidationFlags> for IRCompilerValidationFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        IRCompilerValidationFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for IRCompilerValidationFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: IRCompilerValidationFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IRCompilerValidationFlags(pub ::std::os::raw::c_int);
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRStageInCodeGenerationMode {
    IRStageInCodeGenerationModeUseMetalVertexFetch = 0,
    IRStageInCodeGenerationModeUseSeparateStageInFunction = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDualSourceBlendingConfiguration {
    IRDualSourceBlendingConfigurationDecideAtRuntime = 0,
    IRDualSourceBlendingConfigurationForceEnabled = 1,
    IRDualSourceBlendingConfigurationForceDisabled = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRDepthFeedbackConfiguration {
    IRDepthFeedbackConfigurationDecideAtRuntime = 0,
    IRDepthFeedbackConfigurationForceEnabled = 1,
    IRDepthFeedbackConfigurationForceDisabled = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRGPUFamily {
    IRGPUFamilyApple6 = 1006,
    IRGPUFamilyApple7 = 1007,
    IRGPUFamilyApple8 = 1008,
    IRGPUFamilyMac2 = 2002,
    IRGPUFamilyMetal3 = 5001,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IROperatingSystem {
    IROperatingSystem_macOS = 0,
    IROperatingSystem_iOS = 1,
    IROperatingSystem_tvOS = 2,
    IROperatingSystem_iOSSimulator = 3,
}
#[repr(i32)]
#[doc = " Function constant types. Values match MTLDataType enum."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRFunctionConstantType {
    IRFunctionConstantTypeBool = 53,
    IRFunctionConstantTypeInt = 29,
    IRFunctionConstantTypeFloat = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRFunctionConstant {
    pub name: *const ::std::os::raw::c_char,
    pub type_: IRFunctionConstantType,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IRReflectionVersion {
    IRReflectionVersion_1_0 = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRCSInfo_1_0 {
    pub tg_size: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedCSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedCSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedCSInfo__bindgen_ty_1 {
    pub info_1_0: IRCSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexInputInfo_1_0 {
    pub name: *const ::std::os::raw::c_char,
    pub attributeIndex: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVSInfo_1_0 {
    pub instance_id_index: ::std::os::raw::c_int,
    pub vertex_id_index: ::std::os::raw::c_int,
    pub vertex_output_size_in_bytes: u32,
    pub needs_draw_params: bool,
    pub vertex_inputs: *mut IRVertexInputInfo_1_0,
    pub num_vertex_inputs: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedVSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedVSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedVSInfo__bindgen_ty_1 {
    pub info_1_0: IRVSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRFSInfo_1_0 {
    pub num_render_targets: ::std::os::raw::c_int,
    pub rt_index_int: u8,
    pub discards: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedFSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedFSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedFSInfo__bindgen_ty_1 {
    pub info_1_0: IRFSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRVertexOutputInfo_1_0 {
    pub name: *const ::std::os::raw::c_char,
    pub attributeIndex: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRGSInfo_1_0 {
    pub vertex_outputs: *mut IRVertexOutputInfo_1_0,
    pub num_vertex_outputs: usize,
    pub is_passthrough: bool,
    pub rt_array_index_record_id: i32,
    pub viewport_array_index_record_id: i32,
    pub input_primitive: IRInputPrimitive,
    pub max_input_primitives_per_mesh_threadgroup: u32,
    pub max_payload_size_in_bytes: u32,
    pub instance_count: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedGSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedGSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedGSInfo__bindgen_ty_1 {
    pub info_1_0: IRGSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRHSInfo_1_0 {
    pub max_patches_per_object_threadgroup: u32,
    pub max_object_threads_per_patch: u32,
    pub patch_constants_size: u32,
    pub patch_constant_function: *const ::std::os::raw::c_char,
    pub static_payload_size: u32,
    pub payload_size_per_patch: u32,
    pub input_control_point_count: u32,
    pub output_control_point_count: u32,
    pub output_control_point_size: u32,
    pub tessellator_domain: IRTessellatorDomain,
    pub tessellator_partitioning: IRTessellatorPartitioning,
    pub tessellator_output_primitive: IRTessellatorOutputPrimitive,
    pub tessellation_type_half: bool,
    pub max_tessellation_factor: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedHSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedHSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedHSInfo__bindgen_ty_1 {
    pub info_1_0: IRHSInfo_1_0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRDSInfo_1_0 {
    pub tessellator_domain: IRTessellatorDomain,
    pub max_input_prims_per_mesh_threadgroup: u32,
    pub input_control_point_count: u32,
    pub input_control_point_size: u32,
    pub patch_constants_size: u32,
    pub tessellation_type_half: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IRVersionedDSInfo {
    pub version: IRReflectionVersion,
    pub __bindgen_anon_1: IRVersionedDSInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IRVersionedDSInfo__bindgen_ty_1 {
    pub info_1_0: IRDSInfo_1_0,
}
#[doc = " Represents a shader resource location from reflection data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRResourceLocation {
    #[doc = "< Resource type."]
    pub resourceType: IRResourceType,
    #[doc = "< DXIL space of this resource."]
    pub space: u32,
    #[doc = "< DXIL slot of this resource."]
    pub slot: u32,
    #[doc = "< Offset in bytes into the top-level argument buffer."]
    pub topLevelOffset: u32,
    #[doc = "< Size of the entry in the argument buffer in bytes."]
    pub sizeBytes: u64,
    #[doc = "< Name of the resource. String is non-owned and points into the parent reflection object. May be NULL."]
    pub resourceName: *const ::std::os::raw::c_char,
}
extern crate libloading;
pub struct metal_irconverter {
    __library: ::libloading::Library,
    pub IRErrorGetCode: unsafe extern "C" fn(error: *const IRError) -> u32,
    pub IRErrorGetPayload:
        unsafe extern "C" fn(error: *const IRError) -> *const ::std::os::raw::c_void,
    pub IRErrorDestroy: unsafe extern "C" fn(error: *mut IRError),
    pub IRRootSignatureCreateFromDescriptor: unsafe extern "C" fn(
        descriptor: *const IRVersionedRootSignatureDescriptor,
        error: *mut *mut IRError,
    ) -> *mut IRRootSignature,
    pub IRRootSignatureDestroy: unsafe extern "C" fn(sig: *mut IRRootSignature),
    pub IRObjectCreateFromDXIL: unsafe extern "C" fn(
        bytecode: *const u8,
        size: usize,
        bytecodeOwnership: IRBytecodeOwnership,
    ) -> *mut IRObject,
    pub IRObjectDestroy: unsafe extern "C" fn(object: *mut IRObject),
    pub IRObjectGetType: unsafe extern "C" fn(object: *const IRObject) -> IRObjectType,
    pub IRObjectGetMetalIRShaderStage:
        unsafe extern "C" fn(object: *const IRObject) -> IRShaderStage,
    pub IRCompilerSetValidationFlags:
        unsafe extern "C" fn(compiler: *mut IRCompiler, validationFlags: IRCompilerValidationFlags),
    pub IRCompilerCreate: unsafe extern "C" fn() -> *mut IRCompiler,
    pub IRCompilerDestroy: unsafe extern "C" fn(compiler: *mut IRCompiler),
    pub IRCompilerAllocCompileAndLink: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        entryPointNames: *const *const ::std::os::raw::c_char,
        entryPointCount: usize,
        input: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject,
    pub IRObjectGetMetalLibBinary: unsafe extern "C" fn(
        obj: *const IRObject,
        stage: IRShaderStage,
        lib: *mut IRMetalLibBinary,
    ) -> bool,
    pub IRCompilerSetStageInGenerationMode: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        stageInCodeGenerationMode: IRStageInCodeGenerationMode,
    ),
    pub IRMetalLibSynthesizeStageInFunction: unsafe extern "C" fn(
        compiler: *const IRCompiler,
        vertexShaderReflection: *const IRShaderReflection,
        layout: *const IRVersionedInputLayoutDescriptor,
        binary: *mut IRMetalLibBinary,
    ) -> bool,
    pub IRObjectGetReflection: unsafe extern "C" fn(
        obj: *const IRObject,
        stage: IRShaderStage,
        reflection: *mut IRShaderReflection,
    ) -> bool,
    pub IRCompilerSetGlobalRootSignature:
        unsafe extern "C" fn(compiler: *mut IRCompiler, rootSignature: *const IRRootSignature),
    pub IRCompilerSetCompatibilityFlags:
        unsafe extern "C" fn(compiler: *mut IRCompiler, flags: IRCompatibilityFlags),
    pub IRCompilerSetInputTopology:
        unsafe extern "C" fn(compiler: *mut IRCompiler, inputTopology: IRInputTopology),
    pub IRCompilerEnableGeometryAndTessellationEmulation:
        unsafe extern "C" fn(compiler: *mut IRCompiler, enable: bool),
    pub IRCompilerSetDualSourceBlendingConfiguration: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        configuration: IRDualSourceBlendingConfiguration,
    ),
    pub IRCompilerSetDepthFeedbackConfiguration: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        configuration: IRDepthFeedbackConfiguration,
    ),
    pub IRCompilerSetEntryPointName:
        unsafe extern "C" fn(compiler: *mut IRCompiler, newName: *const ::std::os::raw::c_char),
    pub IRCompilerSetMinimumGPUFamily:
        unsafe extern "C" fn(compiler: *mut IRCompiler, family: IRGPUFamily),
    pub IRCompilerSetMinimumDeploymentTarget: unsafe extern "C" fn(
        compiler: *mut IRCompiler,
        operatingSystem: IROperatingSystem,
        version: *const ::std::os::raw::c_char,
    ),
    pub IRMetalLibBinaryCreate: unsafe extern "C" fn() -> *mut IRMetalLibBinary,
    pub IRMetalLibBinaryDestroy: unsafe extern "C" fn(lib: *mut IRMetalLibBinary),
    pub IRMetalLibGetBytecode:
        unsafe extern "C" fn(lib: *const IRMetalLibBinary, outBytecode: *mut u8) -> usize,
    pub IRMetalLibGetBytecodeSize: unsafe extern "C" fn(lib: *const IRMetalLibBinary) -> usize,
    pub IRObjectSerialize: unsafe extern "C" fn(
        outputPath: *const ::std::os::raw::c_char,
        obj: *const IRObject,
        stage: IRShaderStage,
    ) -> bool,
    pub IRShaderReflectionCreate: unsafe extern "C" fn() -> *mut IRShaderReflection,
    pub IRShaderReflectionDestroy: unsafe extern "C" fn(reflection: *mut IRShaderReflection),
    pub IRShaderReflectionGetEntryPointFunctionName:
        unsafe extern "C" fn(
            reflection: *const IRShaderReflection,
        ) -> *const ::std::os::raw::c_char,
    pub IRShaderReflectionNeedsFunctionConstants:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> bool,
    pub IRShaderReflectionGetFunctionConstantCount:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> usize,
    pub IRShaderReflectionCopyFunctionConstants: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        functionConstants: *mut IRFunctionConstant,
    ),
    pub IRShaderReflectionReleaseFunctionConstants: unsafe extern "C" fn(
        functionConstants: *mut IRFunctionConstant,
        functionConstantCount: usize,
    ),
    pub IRShaderReflectionCopyComputeInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyVertexInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyFragmentInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyGeometryInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyHullInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        hsinfo: *mut IRVersionedHSInfo,
    ) -> bool,
    pub IRShaderReflectionCopyDomainInfo: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool,
    pub IRShaderReflectionReleaseComputeInfo:
        unsafe extern "C" fn(csinfo: *mut IRVersionedCSInfo) -> bool,
    pub IRShaderReflectionReleaseVertexInfo:
        unsafe extern "C" fn(vsinfo: *mut IRVersionedVSInfo) -> bool,
    pub IRShaderReflectionReleaseFragmentInfo:
        unsafe extern "C" fn(fsinfo: *mut IRVersionedFSInfo) -> bool,
    pub IRShaderReflectionReleaseGeometryInfo:
        unsafe extern "C" fn(gsinfo: *mut IRVersionedGSInfo) -> bool,
    pub IRShaderReflectionReleaseHullInfo:
        unsafe extern "C" fn(hsinfo: *mut IRVersionedHSInfo) -> bool,
    pub IRShaderReflectionReleaseDomainInfo:
        unsafe extern "C" fn(dsinfo: *mut IRVersionedDSInfo) -> bool,
    pub IRShaderReflectionGetResourceCount:
        unsafe extern "C" fn(reflection: *const IRShaderReflection) -> usize,
    pub IRShaderReflectionGetResourceLocations: unsafe extern "C" fn(
        reflection: *const IRShaderReflection,
        resourceLocations: *mut IRResourceLocation,
    ),
    pub IRRootSignatureGetResourceCount:
        unsafe extern "C" fn(rootSignature: *const IRRootSignature) -> usize,
    pub IRRootSignatureGetResourceLocations: unsafe extern "C" fn(
        rootSignature: *const IRRootSignature,
        resourceLocations: *mut IRResourceLocation,
    ),
    pub IRShaderReflectionSerialize:
        unsafe extern "C" fn(reflection: *mut IRShaderReflection) -> *const ::std::os::raw::c_char,
    pub IRShaderReflectionDeserialize: unsafe extern "C" fn(
        blob: *const ::std::os::raw::c_char,
        reflection: *mut IRShaderReflection,
    ),
}
impl metal_irconverter {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let IRErrorGetCode = __library.get(b"IRErrorGetCode\0").map(|sym| *sym)?;
        let IRErrorGetPayload = __library.get(b"IRErrorGetPayload\0").map(|sym| *sym)?;
        let IRErrorDestroy = __library.get(b"IRErrorDestroy\0").map(|sym| *sym)?;
        let IRRootSignatureCreateFromDescriptor = __library
            .get(b"IRRootSignatureCreateFromDescriptor\0")
            .map(|sym| *sym)?;
        let IRRootSignatureDestroy = __library.get(b"IRRootSignatureDestroy\0").map(|sym| *sym)?;
        let IRObjectCreateFromDXIL = __library.get(b"IRObjectCreateFromDXIL\0").map(|sym| *sym)?;
        let IRObjectDestroy = __library.get(b"IRObjectDestroy\0").map(|sym| *sym)?;
        let IRObjectGetType = __library.get(b"IRObjectGetType\0").map(|sym| *sym)?;
        let IRObjectGetMetalIRShaderStage = __library
            .get(b"IRObjectGetMetalIRShaderStage\0")
            .map(|sym| *sym)?;
        let IRCompilerSetValidationFlags = __library
            .get(b"IRCompilerSetValidationFlags\0")
            .map(|sym| *sym)?;
        let IRCompilerCreate = __library.get(b"IRCompilerCreate\0").map(|sym| *sym)?;
        let IRCompilerDestroy = __library.get(b"IRCompilerDestroy\0").map(|sym| *sym)?;
        let IRCompilerAllocCompileAndLink = __library
            .get(b"IRCompilerAllocCompileAndLink\0")
            .map(|sym| *sym)?;
        let IRObjectGetMetalLibBinary = __library
            .get(b"IRObjectGetMetalLibBinary\0")
            .map(|sym| *sym)?;
        let IRCompilerSetStageInGenerationMode = __library
            .get(b"IRCompilerSetStageInGenerationMode\0")
            .map(|sym| *sym)?;
        let IRMetalLibSynthesizeStageInFunction = __library
            .get(b"IRMetalLibSynthesizeStageInFunction\0")
            .map(|sym| *sym)?;
        let IRObjectGetReflection = __library.get(b"IRObjectGetReflection\0").map(|sym| *sym)?;
        let IRCompilerSetGlobalRootSignature = __library
            .get(b"IRCompilerSetGlobalRootSignature\0")
            .map(|sym| *sym)?;
        let IRCompilerSetCompatibilityFlags = __library
            .get(b"IRCompilerSetCompatibilityFlags\0")
            .map(|sym| *sym)?;
        let IRCompilerSetInputTopology = __library
            .get(b"IRCompilerSetInputTopology\0")
            .map(|sym| *sym)?;
        let IRCompilerEnableGeometryAndTessellationEmulation = __library
            .get(b"IRCompilerEnableGeometryAndTessellationEmulation\0")
            .map(|sym| *sym)?;
        let IRCompilerSetDualSourceBlendingConfiguration = __library
            .get(b"IRCompilerSetDualSourceBlendingConfiguration\0")
            .map(|sym| *sym)?;
        let IRCompilerSetDepthFeedbackConfiguration = __library
            .get(b"IRCompilerSetDepthFeedbackConfiguration\0")
            .map(|sym| *sym)?;
        let IRCompilerSetEntryPointName = __library
            .get(b"IRCompilerSetEntryPointName\0")
            .map(|sym| *sym)?;
        let IRCompilerSetMinimumGPUFamily = __library
            .get(b"IRCompilerSetMinimumGPUFamily\0")
            .map(|sym| *sym)?;
        let IRCompilerSetMinimumDeploymentTarget = __library
            .get(b"IRCompilerSetMinimumDeploymentTarget\0")
            .map(|sym| *sym)?;
        let IRMetalLibBinaryCreate = __library.get(b"IRMetalLibBinaryCreate\0").map(|sym| *sym)?;
        let IRMetalLibBinaryDestroy = __library
            .get(b"IRMetalLibBinaryDestroy\0")
            .map(|sym| *sym)?;
        let IRMetalLibGetBytecode = __library.get(b"IRMetalLibGetBytecode\0").map(|sym| *sym)?;
        let IRMetalLibGetBytecodeSize = __library
            .get(b"IRMetalLibGetBytecodeSize\0")
            .map(|sym| *sym)?;
        let IRObjectSerialize = __library.get(b"IRObjectSerialize\0").map(|sym| *sym)?;
        let IRShaderReflectionCreate = __library
            .get(b"IRShaderReflectionCreate\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionDestroy = __library
            .get(b"IRShaderReflectionDestroy\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetEntryPointFunctionName = __library
            .get(b"IRShaderReflectionGetEntryPointFunctionName\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionNeedsFunctionConstants = __library
            .get(b"IRShaderReflectionNeedsFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetFunctionConstantCount = __library
            .get(b"IRShaderReflectionGetFunctionConstantCount\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyFunctionConstants = __library
            .get(b"IRShaderReflectionCopyFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseFunctionConstants = __library
            .get(b"IRShaderReflectionReleaseFunctionConstants\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyComputeInfo = __library
            .get(b"IRShaderReflectionCopyComputeInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyVertexInfo = __library
            .get(b"IRShaderReflectionCopyVertexInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyFragmentInfo = __library
            .get(b"IRShaderReflectionCopyFragmentInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyGeometryInfo = __library
            .get(b"IRShaderReflectionCopyGeometryInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyHullInfo = __library
            .get(b"IRShaderReflectionCopyHullInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionCopyDomainInfo = __library
            .get(b"IRShaderReflectionCopyDomainInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseComputeInfo = __library
            .get(b"IRShaderReflectionReleaseComputeInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseVertexInfo = __library
            .get(b"IRShaderReflectionReleaseVertexInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseFragmentInfo = __library
            .get(b"IRShaderReflectionReleaseFragmentInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseGeometryInfo = __library
            .get(b"IRShaderReflectionReleaseGeometryInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseHullInfo = __library
            .get(b"IRShaderReflectionReleaseHullInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionReleaseDomainInfo = __library
            .get(b"IRShaderReflectionReleaseDomainInfo\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetResourceCount = __library
            .get(b"IRShaderReflectionGetResourceCount\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionGetResourceLocations = __library
            .get(b"IRShaderReflectionGetResourceLocations\0")
            .map(|sym| *sym)?;
        let IRRootSignatureGetResourceCount = __library
            .get(b"IRRootSignatureGetResourceCount\0")
            .map(|sym| *sym)?;
        let IRRootSignatureGetResourceLocations = __library
            .get(b"IRRootSignatureGetResourceLocations\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionSerialize = __library
            .get(b"IRShaderReflectionSerialize\0")
            .map(|sym| *sym)?;
        let IRShaderReflectionDeserialize = __library
            .get(b"IRShaderReflectionDeserialize\0")
            .map(|sym| *sym)?;
        Ok(metal_irconverter {
            __library,
            IRErrorGetCode,
            IRErrorGetPayload,
            IRErrorDestroy,
            IRRootSignatureCreateFromDescriptor,
            IRRootSignatureDestroy,
            IRObjectCreateFromDXIL,
            IRObjectDestroy,
            IRObjectGetType,
            IRObjectGetMetalIRShaderStage,
            IRCompilerSetValidationFlags,
            IRCompilerCreate,
            IRCompilerDestroy,
            IRCompilerAllocCompileAndLink,
            IRObjectGetMetalLibBinary,
            IRCompilerSetStageInGenerationMode,
            IRMetalLibSynthesizeStageInFunction,
            IRObjectGetReflection,
            IRCompilerSetGlobalRootSignature,
            IRCompilerSetCompatibilityFlags,
            IRCompilerSetInputTopology,
            IRCompilerEnableGeometryAndTessellationEmulation,
            IRCompilerSetDualSourceBlendingConfiguration,
            IRCompilerSetDepthFeedbackConfiguration,
            IRCompilerSetEntryPointName,
            IRCompilerSetMinimumGPUFamily,
            IRCompilerSetMinimumDeploymentTarget,
            IRMetalLibBinaryCreate,
            IRMetalLibBinaryDestroy,
            IRMetalLibGetBytecode,
            IRMetalLibGetBytecodeSize,
            IRObjectSerialize,
            IRShaderReflectionCreate,
            IRShaderReflectionDestroy,
            IRShaderReflectionGetEntryPointFunctionName,
            IRShaderReflectionNeedsFunctionConstants,
            IRShaderReflectionGetFunctionConstantCount,
            IRShaderReflectionCopyFunctionConstants,
            IRShaderReflectionReleaseFunctionConstants,
            IRShaderReflectionCopyComputeInfo,
            IRShaderReflectionCopyVertexInfo,
            IRShaderReflectionCopyFragmentInfo,
            IRShaderReflectionCopyGeometryInfo,
            IRShaderReflectionCopyHullInfo,
            IRShaderReflectionCopyDomainInfo,
            IRShaderReflectionReleaseComputeInfo,
            IRShaderReflectionReleaseVertexInfo,
            IRShaderReflectionReleaseFragmentInfo,
            IRShaderReflectionReleaseGeometryInfo,
            IRShaderReflectionReleaseHullInfo,
            IRShaderReflectionReleaseDomainInfo,
            IRShaderReflectionGetResourceCount,
            IRShaderReflectionGetResourceLocations,
            IRRootSignatureGetResourceCount,
            IRRootSignatureGetResourceLocations,
            IRShaderReflectionSerialize,
            IRShaderReflectionDeserialize,
        })
    }
    #[doc = " Obtain the error code of an error.\n @param error error object to query.\n @return error code."]
    pub unsafe fn IRErrorGetCode(&self, error: *const IRError) -> u32 {
        (self.IRErrorGetCode)(error)
    }
    #[doc = " Obtain any payload associated with an error.\n @param error error object to query.\n @return error payload. You must cast this pointer to the appropriate error payload struct for the error code."]
    pub unsafe fn IRErrorGetPayload(&self, error: *const IRError) -> *const ::std::os::raw::c_void {
        (self.IRErrorGetPayload)(error)
    }
    #[doc = " Release resources associated with an error object.\n @param error error objects for which to release its associated resources."]
    pub unsafe fn IRErrorDestroy(&self, error: *mut IRError) {
        (self.IRErrorDestroy)(error)
    }
    #[doc = " Create a new root signature from its descriptor.\n @param descriptor description of the root signature to create.\n @param error on return, if the compiler generates any errors, this optional out parameter contains error information. If an error occurs and this parameter is non-NULL, you must free it by calling IRErrorDestroy.\n @return a new root signature suitable for configuring the top-level argument buffer layout of the produced MetalIR, or NULL upon encountering an error. You must destroy this object by calling IRRootSignatureDestroy."]
    pub unsafe fn IRRootSignatureCreateFromDescriptor(
        &self,
        descriptor: *const IRVersionedRootSignatureDescriptor,
        error: *mut *mut IRError,
    ) -> *mut IRRootSignature {
        (self.IRRootSignatureCreateFromDescriptor)(descriptor, error)
    }
    #[doc = " Destroy a root signature object.\n @param sig root signature object to destroy."]
    pub unsafe fn IRRootSignatureDestroy(&self, sig: *mut IRRootSignature) {
        (self.IRRootSignatureDestroy)(sig)
    }
    #[doc = " Create a DXIL object from DXIL bytecode.\n @param bytecode bytecode representing legal DXIL. When using IRBytecodeOwnershipNone, you must ensure this buffer is not freed while the returned object is in use.\n @param size size of the bytecode in bytes.\n @param bytecodeOwnership determine whether the IRObject shall copy the bytecode or just hold a weak reference.\n @return a new DXIL object representing the DXIL shader. You must destroy this object by calling IRObjectDestroy."]
    pub unsafe fn IRObjectCreateFromDXIL(
        &self,
        bytecode: *const u8,
        size: usize,
        bytecodeOwnership: IRBytecodeOwnership,
    ) -> *mut IRObject {
        (self.IRObjectCreateFromDXIL)(bytecode, size, bytecodeOwnership)
    }
    #[doc = " Destroy a IRObject.\n @param object IRObject to destroy."]
    pub unsafe fn IRObjectDestroy(&self, object: *mut IRObject) {
        (self.IRObjectDestroy)(object)
    }
    #[doc = " Query a IRObject's type.\n @param object IRObject to query.\n @return IRObjectTypeDXILBytecode if the object represents DXIL bytecode, IRObjectTypeMetalIRObject if the object represents MetalIR bytecode."]
    pub unsafe fn IRObjectGetType(&self, object: *const IRObject) -> IRObjectType {
        (self.IRObjectGetType)(object)
    }
    #[doc = " Query the shader stage of this IRObject.\n @param object IRObject to query.\n @return the shader stage of this IRObject."]
    pub unsafe fn IRObjectGetMetalIRShaderStage(&self, object: *const IRObject) -> IRShaderStage {
        (self.IRObjectGetMetalIRShaderStage)(object)
    }
    #[doc = " Set a compiler's compile-time validation flags.\n @param compiler compiler for which to set the flags.\n @param validationFlags validation flags denoting the checks the compiler performs."]
    pub unsafe fn IRCompilerSetValidationFlags(
        &self,
        compiler: *mut IRCompiler,
        validationFlags: IRCompilerValidationFlags,
    ) {
        (self.IRCompilerSetValidationFlags)(compiler, validationFlags)
    }
    #[doc = " Create a new compiler instance.\n @return a new compiler instance. You must destroy this object by calling IRCompilerDestroy."]
    pub unsafe fn IRCompilerCreate(&self) -> *mut IRCompiler {
        (self.IRCompilerCreate)()
    }
    #[doc = " Destroy a compiler instance.\n @param compiler compiler to destroy."]
    pub unsafe fn IRCompilerDestroy(&self, compiler: *mut IRCompiler) {
        (self.IRCompilerDestroy)(compiler)
    }
    #[doc = " Allocate a new object and populate it with the results of compiling and linking IR bytecode.\n @param compiler compiler to use for the translation process.\n @param entryPointNames array of entry point names to compile (for ray tracing shaders).\n @param input input IR object.\n @param error on return, if the compiler generates any errors, this optional out parameter contains error information. If an error occurs and this parameter is non-NULL, you must free it by calling IRErrorDestroy.\n @return an IR Object containing MetalIR compiled from the input IR, or NULL if an error occurs. You must destroy this object by calling IRObjectDestroy."]
    pub unsafe fn IRCompilerAllocCompileAndLink(
        &self,
        compiler: *mut IRCompiler,
        entryPointNames: *const *const ::std::os::raw::c_char,
        entryPointCount: usize,
        input: *const IRObject,
        error: *mut *mut IRError,
    ) -> *mut IRObject {
        (self.IRCompilerAllocCompileAndLink)(
            compiler,
            entryPointNames,
            entryPointCount,
            input,
            error,
        )
    }
    #[doc = " Copy the metallib binary, containing MetalIR bytecode.\n @param obj MetalIR object containing the bytecode from where to copy.\n @param stage shader stage to copy.\n @param lib metallib binary into which to copy the metallib.\n @return true if the metallib binary contains bytecode for this shader stage, false otherwise."]
    pub unsafe fn IRObjectGetMetalLibBinary(
        &self,
        obj: *const IRObject,
        stage: IRShaderStage,
        lib: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRObjectGetMetalLibBinary)(obj, stage, lib)
    }
    #[doc = " Configure whether the compiler should generate a Metal vertex fetch, or allow synthesizing a separate stage-in function.\n Use Metal vertex fetch to specify a MTLVertexDescriptor to your pipelines at runtime. Request a separate stage-in function to link vertex fetch as a Metal linked function.\n Using a separate stage-in function provides your shader with more flexitibility to perform type conversions, however, it requires more work to set up.\n @param compiler compiler to configure.\n @param stageInCodeGenerationMode code generation mode for the stage-in function."]
    pub unsafe fn IRCompilerSetStageInGenerationMode(
        &self,
        compiler: *mut IRCompiler,
        stageInCodeGenerationMode: IRStageInCodeGenerationMode,
    ) {
        (self.IRCompilerSetStageInGenerationMode)(compiler, stageInCodeGenerationMode)
    }
    #[doc = " Synthesize a stage in function.\n @param compiler compiler configuration to use.\n @param vertexShaderReflection reflection object of a vertex stage containing the inputs used as a base for synthesis.\n @param layout vertex input layout descriptor.\n @param binary pointer to a binary into which to write the synthesized MetalIR.\n @return true if the stageIn function could be successfully created, false otherwise."]
    pub unsafe fn IRMetalLibSynthesizeStageInFunction(
        &self,
        compiler: *const IRCompiler,
        vertexShaderReflection: *const IRShaderReflection,
        layout: *const IRVersionedInputLayoutDescriptor,
        binary: *mut IRMetalLibBinary,
    ) -> bool {
        (self.IRMetalLibSynthesizeStageInFunction)(compiler, vertexShaderReflection, layout, binary)
    }
    #[doc = " Copy reflection data stemming from the process of compiling DXIL to MetalIR.\n @param obj MetalIR object containing the metadata to copy.\n @param stage shader stage from where to obtain the reflection.\n @param reflection reflection object into which to copy the reflection data.\n @return true if the metallib binary contains bytecode for this shader stage, false otherwise."]
    pub unsafe fn IRObjectGetReflection(
        &self,
        obj: *const IRObject,
        stage: IRShaderStage,
        reflection: *mut IRShaderReflection,
    ) -> bool {
        (self.IRObjectGetReflection)(obj, stage, reflection)
    }
    #[doc = " Configure a compiler to emit a shader that consumes a top-level Argument Buffer layout matching a specific root signature.\n @param compiler compiler to configure.\n @param rootSignature root signature that defines the layout of the top-level Argument Buffer for any shaders you compile with this compiler.\n Pass in NULL (the default) to have the compiler generate a linear resource layout instead. If you provide a non-NULL rootSignature, you must ensure it is not destroyed before the compiler."]
    pub unsafe fn IRCompilerSetGlobalRootSignature(
        &self,
        compiler: *mut IRCompiler,
        rootSignature: *const IRRootSignature,
    ) {
        (self.IRCompilerSetGlobalRootSignature)(compiler, rootSignature)
    }
    #[doc = " Configure compiler compatibility flags.\n Compatibility flags allow you to tailor code generation to the specific requirements of your shaders.\n You typically enable compatibility flags to support a broader set of features and behaviors (such as out-of-bounds reads) when your shader needs them to operate correctly.\n These flags, however, carry a performance cost.\n Always use the minimum set of compatibility flags your shader needs to attain the highest runtime performance for IR code you compile.\n @param compiler the compiler to configure\n @param flags bitmask of compatibility flags to enable."]
    pub unsafe fn IRCompilerSetCompatibilityFlags(
        &self,
        compiler: *mut IRCompiler,
        flags: IRCompatibilityFlags,
    ) {
        (self.IRCompilerSetCompatibilityFlags)(compiler, flags)
    }
    #[doc = " Set primitive input topology\n Provides the compiler with information about input topology this shader will be used with.\n This information is required to correctly compile shaders that will render point primitive and may be used for other optimizations.\n @param compiler the compiler to configure\n @param inputTopology input topology"]
    pub unsafe fn IRCompilerSetInputTopology(
        &self,
        compiler: *mut IRCompiler,
        inputTopology: IRInputTopology,
    ) {
        (self.IRCompilerSetInputTopology)(compiler, inputTopology)
    }
    #[doc = " Enable geometry and tessellation emulation.\n @param compiler compiler to enable tessellation emulation\n @param enable pass in true to enable geometry emulation, false to disable it."]
    pub unsafe fn IRCompilerEnableGeometryAndTessellationEmulation(
        &self,
        compiler: *mut IRCompiler,
        enable: bool,
    ) {
        (self.IRCompilerEnableGeometryAndTessellationEmulation)(compiler, enable)
    }
    #[doc = " Enable dual-source blending support.\n When the configuration parameter is set to `IRDualSourceBlendingConfigurationDecideAtRuntime`, you must provide a function constant named \"`dualSourceBlendingEnabled`\" of type `uint8_t` at\n pipeline creation time, specifying whether to enable dual source blending.\n @param compiler compiler to configure.\n @param configuration set to enabled or disable to enable and disable support. Set to decide-at-runtime to control support at PSO-creation time via function constants.\n This parameter is reset after each compilation."]
    pub unsafe fn IRCompilerSetDualSourceBlendingConfiguration(
        &self,
        compiler: *mut IRCompiler,
        configuration: IRDualSourceBlendingConfiguration,
    ) {
        (self.IRCompilerSetDualSourceBlendingConfiguration)(compiler, configuration)
    }
    #[doc = " Enable depth feedback support.\n When the configuration parameter is set to `IRDepthWriteConfigurationDecideAtRuntime`, you must provide a function constant named \"`depthFeedbackEnabled`\" of type `uint8_t` at\n pipeline creation time, specifying whether to enable depth feedback.\n @param compiler compiler to configure.\n @param configuration set to enabled or disable to enable and disable support. Set to decide-at-runtime to control support at PSO-creation time via function constants.\n This parameter is reset after each compilation."]
    pub unsafe fn IRCompilerSetDepthFeedbackConfiguration(
        &self,
        compiler: *mut IRCompiler,
        configuration: IRDepthFeedbackConfiguration,
    ) {
        (self.IRCompilerSetDepthFeedbackConfiguration)(compiler, configuration)
    }
    #[doc = " Customize the name of the entry point functions generated by a compiler.\n @param compiler compiler to configure.\n @param newName name IRConverter assigns to the emited entry point."]
    pub unsafe fn IRCompilerSetEntryPointName(
        &self,
        compiler: *mut IRCompiler,
        newName: *const ::std::os::raw::c_char,
    ) {
        (self.IRCompilerSetEntryPointName)(compiler, newName)
    }
    #[doc = " Set the minimum GPU deployment target for MetalIR code generation.\n Targetting a newer family may enable the compiler to emit MetalIR further optimized for newer GPUs, but may render it incompatible with older models.\n @param compiler compiler to configure.\n @param family minimum GPU family supported by code generation."]
    pub unsafe fn IRCompilerSetMinimumGPUFamily(
        &self,
        compiler: *mut IRCompiler,
        family: IRGPUFamily,
    ) {
        (self.IRCompilerSetMinimumGPUFamily)(compiler, family)
    }
    #[doc = " Set the minimum operating system software version target for Metal IR code generation.\n Targetting a newer software version may enable the compiler to emi MetalIR further optimized for newer macOS and iOS releases, but it may render it incompatible with older operating system versions.\n Setting a minimum deployment target newer than your SDK may produce an `IRErrorCodeUnableToLinkModule` error.\n @param compiler compiler to configure.\n @param operatingSystem operating system name.\n @param version operating system version, such as \"13.0.0\" or \"16.0.0\"."]
    pub unsafe fn IRCompilerSetMinimumDeploymentTarget(
        &self,
        compiler: *mut IRCompiler,
        operatingSystem: IROperatingSystem,
        version: *const ::std::os::raw::c_char,
    ) {
        (self.IRCompilerSetMinimumDeploymentTarget)(compiler, operatingSystem, version)
    }
    #[doc = " Create an empty metallib binary.\n @return a new, empty metallib binary."]
    pub unsafe fn IRMetalLibBinaryCreate(&self) -> *mut IRMetalLibBinary {
        (self.IRMetalLibBinaryCreate)()
    }
    #[doc = " Destroy a metallib binary.\n @param lib library to destroy."]
    pub unsafe fn IRMetalLibBinaryDestroy(&self, lib: *mut IRMetalLibBinary) {
        (self.IRMetalLibBinaryDestroy)(lib)
    }
    #[doc = " Copy the bytecode from a metallib library into a byte array.\n @param lib metallib library from where to copy the bytecode.\n @param outBytecode into which to write the bytecode. This parameter must be an array of at least IRMetalLibGetBytecodeSize bytes.\n @return number of bytes written."]
    pub unsafe fn IRMetalLibGetBytecode(
        &self,
        lib: *const IRMetalLibBinary,
        outBytecode: *mut u8,
    ) -> usize {
        (self.IRMetalLibGetBytecode)(lib, outBytecode)
    }
    #[doc = " Obtain the number of bytes needed to store the bytecode in a metallib.\n @param lib metallib to query.\n @return size in bytes needed to store the metallib's bytecode."]
    pub unsafe fn IRMetalLibGetBytecodeSize(&self, lib: *const IRMetalLibBinary) -> usize {
        (self.IRMetalLibGetBytecodeSize)(lib)
    }
    #[doc = " Serialize an MetalIR object's shader bytecode to disk.\n @param outputPath path into which to write the serialized MetalIR.\n @param obj IRObject containing the bytecode to serialize.\n @param stage shader stage to serialize."]
    pub unsafe fn IRObjectSerialize(
        &self,
        outputPath: *const ::std::os::raw::c_char,
        obj: *const IRObject,
        stage: IRShaderStage,
    ) -> bool {
        (self.IRObjectSerialize)(outputPath, obj, stage)
    }
    #[doc = " Create an empty reflection object.\n @return a new empty reflection object."]
    pub unsafe fn IRShaderReflectionCreate(&self) -> *mut IRShaderReflection {
        (self.IRShaderReflectionCreate)()
    }
    #[doc = " Release a reflection object.\n @param reflection reflection object to release."]
    pub unsafe fn IRShaderReflectionDestroy(&self, reflection: *mut IRShaderReflection) {
        (self.IRShaderReflectionDestroy)(reflection)
    }
    #[doc = " Obtain the name of the entry point from a reflection object.\n @return pointer to the name of the entry point. Do not free this pointer, its lifecycle is managed by, and coincides with, the reflection object's."]
    pub unsafe fn IRShaderReflectionGetEntryPointFunctionName(
        &self,
        reflection: *const IRShaderReflection,
    ) -> *const ::std::os::raw::c_char {
        (self.IRShaderReflectionGetEntryPointFunctionName)(reflection)
    }
    #[doc = " Determine whether the shader requires supplemental information to operate correctly.\n @param reflection reflection object to evaluate.\n @return true if the compiled shader requires supplemental information in the form of function constants, false otherwise."]
    pub unsafe fn IRShaderReflectionNeedsFunctionConstants(
        &self,
        reflection: *const IRShaderReflection,
    ) -> bool {
        (self.IRShaderReflectionNeedsFunctionConstants)(reflection)
    }
    #[doc = " Obtain the number of function constants in the reflection object.\n @param reflection reflection object to query.\n @return function constant count. May be zero if the shader stage to which this reflection corresponds has no function constants."]
    pub unsafe fn IRShaderReflectionGetFunctionConstantCount(
        &self,
        reflection: *const IRShaderReflection,
    ) -> usize {
        (self.IRShaderReflectionGetFunctionConstantCount)(reflection)
    }
    #[doc = " Copy function constant reflection data from a reflection object to an array.\n You are responsible for calling IRShaderReflectionReleaseFunctionConstants on the array to ensure copied function constant reflection data are released.\n @param reflection reflection object to query.\n @param functionConstants function constants array into which to write the reflection data. This object needs to be able to store at least\n IRShaderReflectionFunctionConstantCount function constants."]
    pub unsafe fn IRShaderReflectionCopyFunctionConstants(
        &self,
        reflection: *const IRShaderReflection,
        functionConstants: *mut IRFunctionConstant,
    ) {
        (self.IRShaderReflectionCopyFunctionConstants)(reflection, functionConstants)
    }
    #[doc = " Release function constant data.\n @param functionConstants array of function constants.\n @param functionConstantCount number of function constants in the array."]
    pub unsafe fn IRShaderReflectionReleaseFunctionConstants(
        &self,
        functionConstants: *mut IRFunctionConstant,
        functionConstantCount: usize,
    ) {
        (self.IRShaderReflectionReleaseFunctionConstants)(functionConstants, functionConstantCount)
    }
    #[doc = " Copy shader reflection for a compute stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param csinfo pointer to a versioned CS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseComputeInfo.\n @return true if the reflection object contains compute reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyComputeInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyComputeInfo)(reflection, version, csinfo)
    }
    #[doc = " Copy shader reflection for a vertex stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param vsinfo pointer to a versioned VS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseVertexInfo.\n @return true if the reflection object contains vertex stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyVertexInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyVertexInfo)(reflection, version, vsinfo)
    }
    #[doc = " Copy shader reflection for a fragment stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param fsinfo pointer to a versioned FS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseFragmentInfo.\n @return true if the reflection object contains fragment stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyFragmentInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyFragmentInfo)(reflection, version, fsinfo)
    }
    #[doc = " Copy shader reflection for a geometry stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param gsinfo pointer to a versioned GS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseGeometryInfo.\n @return true if the reflection object contains geometry stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyGeometryInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyGeometryInfo)(reflection, version, gsinfo)
    }
    #[doc = " Copy shader reflection for a hull shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param hsinfo pointer to a versioned HS Info struct into which to copy the reflection data for the stage. You must release the contents of this stuct by calling IRShaderReflectionReleaseHullInfo.\n @return true if the reflection object contains hull shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyHullInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        hsinfo: *mut IRVersionedHSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyHullInfo)(reflection, version, hsinfo)
    }
    #[doc = " Copy shader reflection for a domain shader stage.\n @param reflection reflection object to query.\n @param version version of the reflection data to obtain.\n @param dsinfo pointer to a versioned DS Info struct into which to copy the reflection data for the stage.  You must release the contents of this stuct by calling IRShaderReflectionReleaseDomainInfo.\n @return true if the reflection object contains domain shader stage reflection information for the specified version."]
    pub unsafe fn IRShaderReflectionCopyDomainInfo(
        &self,
        reflection: *const IRShaderReflection,
        version: IRReflectionVersion,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool {
        (self.IRShaderReflectionCopyDomainInfo)(reflection, version, dsinfo)
    }
    #[doc = " Release versioned compute information.\n @param csinfo pointer to the compute shader reflection information to release.\n @return false if the csinfo version is an unrecognized version or the csinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseComputeInfo(
        &self,
        csinfo: *mut IRVersionedCSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseComputeInfo)(csinfo)
    }
    #[doc = " Release versioned vertex stage information.\n @param vsinfo pointer to the vertex shader reflection information to release.\n @return false if the vsinfo version is an unrecognized version or the vsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseVertexInfo(
        &self,
        vsinfo: *mut IRVersionedVSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseVertexInfo)(vsinfo)
    }
    #[doc = " Release versioned fragment stage information.\n @param fsinfo pointer to the fragment shader reflection information to release.\n @return false if the fsinfo version is an unrecognized version or the fsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseFragmentInfo(
        &self,
        fsinfo: *mut IRVersionedFSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseFragmentInfo)(fsinfo)
    }
    #[doc = " Release versioned geometry stage information.\n @param gsinfo pointer to the geometry shader reflection information to release.\n @return false if the gsinfo version is an unrecognized version or the gsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseGeometryInfo(
        &self,
        gsinfo: *mut IRVersionedGSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseGeometryInfo)(gsinfo)
    }
    #[doc = " Release versioned hull stage information.\n @param hsinfo pointer to the hull shader reflection information to release.\n @return false if the hsinfo version is an unrecognized version or the hsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseHullInfo(&self, hsinfo: *mut IRVersionedHSInfo) -> bool {
        (self.IRShaderReflectionReleaseHullInfo)(hsinfo)
    }
    #[doc = " Release versioned domain stage information.\n @param dsinfo pointer to the domain shader reflection information to release.\n @return false if the dsinfo version is an unrecognized version or the dsinfo pointer is null."]
    pub unsafe fn IRShaderReflectionReleaseDomainInfo(
        &self,
        dsinfo: *mut IRVersionedDSInfo,
    ) -> bool {
        (self.IRShaderReflectionReleaseDomainInfo)(dsinfo)
    }
    #[doc = " Obtain the number of resources referenced by the top-level argument buffer\n @param reflection the reflection object for which to obtain the resource count.\n @return number of resources the top-level argument buffer references."]
    pub unsafe fn IRShaderReflectionGetResourceCount(
        &self,
        reflection: *const IRShaderReflection,
    ) -> usize {
        (self.IRShaderReflectionGetResourceCount)(reflection)
    }
    #[doc = " Get the locations within the top-level Argument Buffer for all top-level resources.\n @param reflection the reflection object resulting from the compilation process.\n @param resourceLocations parameter into which to write resource locations. This array must contain enough storage to write IRShaderReflectionGetResourceCount() elements.\n @note string references within the resource locations are pointers into the reflection object. The reflection object's lifecycle must be preserved while accessing these strings. Names may be NULL."]
    pub unsafe fn IRShaderReflectionGetResourceLocations(
        &self,
        reflection: *const IRShaderReflection,
        resourceLocations: *mut IRResourceLocation,
    ) {
        (self.IRShaderReflectionGetResourceLocations)(reflection, resourceLocations)
    }
    #[doc = " Obtain the number of resources referenced in a top-level Argument Buffer using a hierarchical layout.\n @param rootSignature root signature corresponding to the hierarchical layout definition.\n @return number of resources the top-level argument buffer references."]
    pub unsafe fn IRRootSignatureGetResourceCount(
        &self,
        rootSignature: *const IRRootSignature,
    ) -> usize {
        (self.IRRootSignatureGetResourceCount)(rootSignature)
    }
    #[doc = " Get the locations of resources in the top-level Argument Buffer.\n @param rootSignature root signature corresponding to the hierarchical layout definition.\n @param resourceLocations parameter into which to write resource locations. This array must contain enough storage to write IRRootSignatureGetResourceCount() elements."]
    pub unsafe fn IRRootSignatureGetResourceLocations(
        &self,
        rootSignature: *const IRRootSignature,
        resourceLocations: *mut IRResourceLocation,
    ) {
        (self.IRRootSignatureGetResourceLocations)(rootSignature, resourceLocations)
    }
    #[doc = " Serialize reflection information into JSON.\n @param reflection reflection object.\n @return null-terminated string containing JSON. You are responsible for freeing this string."]
    pub unsafe fn IRShaderReflectionSerialize(
        &self,
        reflection: *mut IRShaderReflection,
    ) -> *const ::std::os::raw::c_char {
        (self.IRShaderReflectionSerialize)(reflection)
    }
    #[doc = " Deserialize a JSON string into a reflection object.\n @param blob null-terminated JSON string containing reflection information.\n @param reflection reflection object into which to deserialize."]
    pub unsafe fn IRShaderReflectionDeserialize(
        &self,
        blob: *const ::std::os::raw::c_char,
        reflection: *mut IRShaderReflection,
    ) {
        (self.IRShaderReflectionDeserialize)(blob, reflection)
    }
}
